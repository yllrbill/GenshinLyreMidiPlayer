diff --git a/.claude/commands/repo-audit.md b/.claude/commands/repo-audit.md
new file mode 100644
index 0000000..db67366
--- /dev/null
+++ b/.claude/commands/repo-audit.md
@@ -0,0 +1,59 @@
+# /repo-audit - 文件修改审计报告
+
+> 输出本次会话的文件修改审计报告，列出所有变更文件及其行号范围。
+
+## 用法
+
+```
+/repo-audit
+```
+
+## 功能
+
+1. **只读审计** - 不修改任何文件
+2. **全覆盖** - tracked/untracked、staged/unstaged 全部覆盖
+3. **可复跑** - 输出完整命令和证据
+4. **精确行号** - 从 git diff hunk header 提取变更行范围
+
+## 输出内容
+
+- **定位信息**: 工作目录、仓库根、当前分支、HEAD
+- **总览表**: 状态、路径、staged、行范围摘要
+- **逐文件细节**: 每个文件的 diff 和行号范围
+- **完整 Patch**: git diff 和 git diff --cached 全文
+
+## 执行步骤
+
+1. `git rev-parse --show-toplevel` - 获取仓库根
+2. `git status --porcelain=v1 -uall` - 获取变更清单
+3. `git diff --unified=0 -- <path>` - 获取每个文件的 unstaged 变更
+4. `git diff --cached --unified=0 -- <path>` - 获取每个文件的 staged 变更
+5. 生成审计报告
+
+## 输出格式
+
+```markdown
+# 文件修改审计报告
+
+## 定位信息
+| 项目 | 值 |
+|------|-----|
+| 工作目录 | ... |
+| 仓库根目录 | ... |
+
+## 变更总览
+| 状态 | 路径 | Staged | 行范围 |
+|------|------|--------|--------|
+| M | file.py | No | -10,3 +10,5 |
+
+## 逐文件细节
+### [M] file.py
+...
+
+## 完整 Patch
+...
+```
+
+---
+
+调用 Skill: `repo-audit-core`
diff --git a/.claude/skills/repo-audit-core/SKILL.md b/.claude/skills/repo-audit-core/SKILL.md
new file mode 100644
index 0000000..ffdf372
--- /dev/null
+++ b/.claude/skills/repo-audit-core/SKILL.md
@@ -0,0 +1,445 @@
+---
+name: repo-audit-core
+description: 会话文件修改审计报告 - 只读分析所有变更文件并输出可复跑报告
+allowed-tools: Bash(*), Read(*), Glob(*)
+---
+
+# Repo Audit Skill
+
+> 输出"本次会话的文件修改审计报告"，列出所有被修改/新增/删除/重命名的文件，并给出每个文件的修改内容与变更行范围（行号）。
+
+## 硬规则
+
+1. **只读操作** - 只做读取/分析/汇总，不修改任何文件、不运行写入磁盘的命令
+2. **覆盖所有变更类型**：
+   - tracked: Modified / Added / Deleted / Renamed / Copied
+   - untracked: 新建但未加入 git 的文件
+   - staged 与 unstaged 都要覆盖
+3. **可复跑、可核对** - 必须输出仓库根路径、工作目录、使用的命令及其输出依据
+4. **行号精确** - 使用 `git diff --unified=0` 从 hunk header 提取变更行范围
+5. **确定性输出** - 按路径字典序排序
+
+## 触发条件
+
+当用户请求：
+- "审计报告"
+- "文件变更审计"
+- "repo audit"
+- "变更清单"
+- "本次改了什么"
+- "修改了哪些文件"
+
+## 执行流程
+
+### Phase 1: 定位信息
+
+```bash
+# 输出当前工作目录
+pwd
+
+# 输出仓库根目录
+git rev-parse --show-toplevel
+
+# 输出当前分支
+git branch --show-current
+
+# 输出 HEAD commit
+git rev-parse --short HEAD
+```
+
+**输出格式**：
+```yaml
+location:
+  cwd: <pwd output>
+  repo_root: <git rev-parse --show-toplevel output>
+  branch: <current branch>
+  head: <HEAD commit short hash>
+```
+
+### Phase 2: 采集变更清单
+
+```bash
+# 完整状态（含 untracked）
+git status --porcelain=v1 -uall
+
+# unstaged 变更文件列表
+git diff --name-status
+
+# staged 变更文件列表
+git diff --cached --name-status
+
+# 仅 untracked 文件列表
+git ls-files --others --exclude-standard
+```
+
+**状态码解析**：
+
+| 状态码 | 含义 |
+|--------|------|
+| M | Modified (已修改) |
+| A | Added (新增到暂存区) |
+| D | Deleted (已删除) |
+| R | Renamed (重命名) |
+| C | Copied (复制) |
+| ?? | Untracked (未跟踪) |
+| !! | Ignored (被忽略) |
+
+### Phase 3: 逐文件 Diff 分析
+
+对每个变更文件执行：
+
+#### 3.1 Unstaged 变更
+
+```bash
+git diff --unified=0 -- <path>
+```
+
+#### 3.2 Staged 变更
+
+```bash
+git diff --cached --unified=0 -- <path>
+```
+
+#### 3.3 Untracked 文件
+
+**判断文件类型**：
+```bash
+# 检查是否为二进制
+file --mime-type <path> | grep -q 'text/' && echo "TEXT" || echo "BINARY"
+```
+
+**文本文件处理**：
+- 行数 ≤ 300: 输出完整内容
+- 行数 > 300: 输出前 200 行 + 后 100 行 + 截断说明
+
+```bash
+wc -l < <path>
+head -n 200 <path>
+tail -n 100 <path>
+```
+
+**二进制文件处理**：
+```bash
+# 输出文件大小
+stat --printf="%s" <path>  # Linux
+stat -f%z <path>           # macOS
+(Get-Item <path>).Length   # PowerShell
+
+# 输出 SHA256
+sha256sum <path>           # Linux
+shasum -a 256 <path>       # macOS
+certutil -hashfile <path> SHA256  # Windows
+```
+
+### Phase 4: 行号范围提取
+
+从 diff hunk header 提取行号：
+
+**Hunk Header 格式**：
+```
+@@ -a,b +c,d @@
+```
+
+| 字段 | 含义 |
+|------|------|
+| `-a` | 原文件起始行号 |
+| `b` | 删除的行数 (省略时为 1) |
+| `+c` | 新文件起始行号 |
+| `d` | 新增的行数 (省略时为 1) |
+
+**提取命令**：
+```bash
+git diff --unified=0 -- <path> | grep '^@@' | sed 's/@@ //' | sed 's/ @@.*//'
+```
+
+**解析示例**：
+```
+@@ -10,3 +10,5 @@  → 删除 10-12 行，新增 10-14 行
+@@ -25 +25,0 @@    → 删除第 25 行，新增 0 行
+@@ -0,0 +1,50 @@  → 新文件，1-50 行全部新增
+```
+
+### Phase 5: 输出报告
+
+#### A) 总览表
+
+```markdown
+## 变更总览
+
+| 状态 | 相对路径 | 绝对路径 | Staged | 行范围摘要 |
+|------|----------|----------|--------|------------|
+| M | src/main.py | /repo/src/main.py | Yes | -10,3 +10,5; -50,1 +50,2 |
+| A | new_file.txt | /repo/new_file.txt | Yes | +1,100 |
+| D | old_file.txt | /repo/old_file.txt | No | -1,50 |
+| ?? | scratch.py | /repo/scratch.py | - | (untracked, 25 lines) |
+```
+
+#### B) 逐文件细节
+
+每个文件一个小节：
+
+```markdown
+### [M] src/main.py
+
+**状态**: Modified
+**路径**: /repo/src/main.py
+
+#### Staged 变更
+无
+
+#### Unstaged 变更
+
+**Hunk 1**: -10,3 +10,5
+- 删除范围: 第 10-12 行
+- 新增范围: 第 10-14 行
+
+```diff
+@@ -10,3 +10,5 @@
+-old line 1
+-old line 2
+-old line 3
++new line 1
++new line 2
++new line 3
++new line 4
++new line 5
+```
+
+**Hunk 2**: -50,1 +50,2
+- 删除范围: 第 50 行
+- 新增范围: 第 50-51 行
+
+```diff
+@@ -50,1 +50,2 @@
+-old single line
++new line A
++new line B
+```
+```
+
+#### C) 完整 Patch（可选）
+
+```markdown
+## 完整 Patch
+
+### Unstaged Diff
+```diff
+<git diff 完整输出>
+```
+
+### Staged Diff
+```diff
+<git diff --cached 完整输出>
+```
+```
+
+## 非 Git 仓库处理
+
+如果 `git rev-parse --show-toplevel` 失败：
+
+```yaml
+warning:
+  status: NOT_GIT_REPO
+  message: "当前目录不是 git 仓库"
+  fallback: "使用文件系统时间戳进行差分分析"
+```
+
+**备选方案**：
+1. 使用 `find` 按修改时间列出最近变更的文件
+2. 对比文件 mtime 与会话开始时间
+3. 尽量模拟 hunk 格式输出
+
+```bash
+# 列出最近 N 分钟内修改的文件
+find . -type f -mmin -<minutes> -not -path './.git/*' | sort
+```
+
+## 输出示例
+
+```markdown
+# 文件修改审计报告
+
+生成时间: 2026-01-05 15:30:00
+
+## 定位信息
+
+| 项目 | 值 |
+|------|-----|
+| 工作目录 | d:\dw11\piano |
+| 仓库根目录 | d:\dw11\piano |
+| 当前分支 | main |
+| HEAD | abc1234 |
+
+## 变更总览
+
+| 状态 | 相对路径 | Staged | 行范围摘要 |
+|------|----------|--------|------------|
+| M | LyreAutoPlayer/main.py | No | -25,3 +25,8 |
+| M | LyreAutoPlayer/ui/editor.py | Yes | -100,10 +100,15 |
+| ?? | new_script.py | - | (new, 45 lines) |
+
+共 3 个文件变更
+
+---
+
+### [M] LyreAutoPlayer/main.py
+
+**状态**: Modified (unstaged)
+**绝对路径**: d:\dw11\piano\LyreAutoPlayer\main.py
+
+#### Unstaged 变更
+
+**Hunk 1**: @@ -25,3 +25,8 @@
+- 删除范围: 第 25-27 行 (3 行)
+- 新增范围: 第 25-32 行 (8 行)
+
+```diff
+@@ -25,3 +25,8 @@
+-    old_code()
+-    more_old()
+-    final_old()
++    new_code()
++    more_new()
++    even_more()
++    additional()
++    extra_line()
++    another_extra()
++    yet_another()
++    last_line()
+```
+
+---
+
+### [??] new_script.py
+
+**状态**: Untracked (new file)
+**绝对路径**: d:\dw11\piano\new_script.py
+**文件大小**: 1,234 bytes
+**行数**: 45 行
+
+#### 文件内容
+
+```python
+#!/usr/bin/env python3
+"""New script for testing."""
+
+def main():
+    print("Hello, World!")
+    # ... (完整内容)
+
+if __name__ == "__main__":
+    main()
+```
+
+---
+
+## 完整 Patch
+
+### Unstaged Diff
+
+```diff
+diff --git a/LyreAutoPlayer/main.py b/LyreAutoPlayer/main.py
+index abc1234..def5678 100644
+--- a/LyreAutoPlayer/main.py
++++ b/LyreAutoPlayer/main.py
+@@ -25,3 +25,8 @@
+...
+```
+
+### Staged Diff
+
+```diff
+diff --git a/LyreAutoPlayer/ui/editor.py b/LyreAutoPlayer/ui/editor.py
+...
+```
+```
+
+## 跨平台兼容
+
+### Windows PowerShell
+
+```powershell
+# 文件大小
+(Get-Item <path>).Length
+
+# SHA256
+(Get-FileHash <path> -Algorithm SHA256).Hash
+
+# 文件类型判断（简化）
+$ext = [System.IO.Path]::GetExtension(<path>)
+$binaryExts = @('.exe', '.dll', '.bin', '.zip', '.tar', '.gz', '.7z', '.rar', '.jpg', '.png', '.gif', '.pdf', '.doc', '.xls')
+if ($binaryExts -contains $ext) { "BINARY" } else { "TEXT" }
+```
+
+### Unix/WSL bash
+
+```bash
+# 文件大小
+stat --printf="%s" <path>
+
+# SHA256
+sha256sum <path> | cut -d' ' -f1
+
+# 文件类型判断
+file --mime-type <path> | grep -q 'text/' && echo "TEXT" || echo "BINARY"
+```
+
+## 安全约束
+
+1. **绝不修改任何文件** - 只读操作
+2. **绝不执行写入命令** - 禁止 `git add`, `git commit`, `rm`, `mv` 等
+3. **敏感内容处理** - 如果文件内容包含明显的密钥/token 模式，在报告中标记 `[SENSITIVE - REDACTED]`
+
+## 敏感内容检测模式
+
+```regex
+# API Key 模式
+(api[_-]?key|apikey)\s*[:=]\s*['"][^'"]{20,}['"]
+
+# Token 模式
+(token|secret|password)\s*[:=]\s*['"][^'"]+['"]
+
+# AWS 密钥
+AKIA[0-9A-Z]{16}
+
+# 私钥
+-----BEGIN (RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----
+```
+
+如果检测到敏感内容，输出：
+
+```markdown
+**注意**: 此文件可能包含敏感信息，内容已脱敏
+
+```
+[SENSITIVE CONTENT - 3 potential secrets detected]
+Line 15: api_key = "[REDACTED]"
+Line 28: token = "[REDACTED]"
+Line 45: password = "[REDACTED]"
+```
+```
+
+## 错误处理
+
+### Git 不可用
+
+```yaml
+error:
+  status: GIT_NOT_AVAILABLE
+  message: "git 命令不可用"
+  suggestion: "请安装 git 或检查 PATH 环境变量"
+```
+
+### 权限错误
+
+```yaml
+error:
+  status: PERMISSION_DENIED
+  message: "无法读取文件 <path>"
+  suggestion: "检查文件权限"
+```
+
+---
+
+*创建时间: 2026-01-05*
+*优先级: LOW (只读审计)*
diff --git a/LyreAutoPlayer/i18n/translations.py b/LyreAutoPlayer/i18n/translations.py
index 1525ef2..95af1b4 100644
--- a/LyreAutoPlayer/i18n/translations.py
+++ b/LyreAutoPlayer/i18n/translations.py
@@ -246,4 +246,20 @@ TRANSLATIONS = {
         LANG_EN: "Apply duration change to selected notes",
         LANG_ZH: "将时值变化应用到选中音符",
     },
+    # Bar duration adjustment
+    "bar_duration_label": {LANG_EN: " Bar: ", LANG_ZH: " 小节: "},
+    "bar_duration_tooltip": {
+        LANG_EN: "Time stretch/compress selected bars (ms, Ctrl+drag timeline to select)",
+        LANG_ZH: "拉伸/压缩选中小节的时值（毫秒，Ctrl+拖拽时间轴选择小节）",
+    },
+    "apply_bar_duration": {LANG_EN: "Stretch", LANG_ZH: "拉伸"},
+    "apply_bar_duration_tooltip": {
+        LANG_EN: "Apply time stretch to notes in selected bars",
+        LANG_ZH: "将时值变化应用到选中小节内的音符",
+    },
+    "no_bars_selected_title": {LANG_EN: "Bar Duration", LANG_ZH: "小节时长"},
+    "no_bars_selected_msg": {
+        LANG_EN: "No bars selected.\nCtrl+drag on the timeline to select bars.",
+        LANG_ZH: "未选中任何小节。\n在时间轴上按住 Ctrl 拖拽选择小节。",
+    },
 }
diff --git a/LyreAutoPlayer/ui/editor/editor_window.py b/LyreAutoPlayer/ui/editor/editor_window.py
index 36357c7..0b9dba7 100644
--- a/LyreAutoPlayer/ui/editor/editor_window.py
+++ b/LyreAutoPlayer/ui/editor/editor_window.py
@@ -319,6 +319,24 @@ class EditorWindow(QMainWindow):
 
         toolbar2.addSeparator()
 
+        # 小节时值调整 (Bar Duration Adjust)
+        toolbar2.addWidget(QLabel(tr("bar_duration_label")))
+        self.spin_bar_duration_delta = QSpinBox()
+        self.spin_bar_duration_delta.setRange(-5000, 5000)
+        self.spin_bar_duration_delta.setSingleStep(50)
+        self.spin_bar_duration_delta.setValue(0)
+        self.spin_bar_duration_delta.setSuffix(" ms")
+        self.spin_bar_duration_delta.setFixedWidth(90)
+        self.spin_bar_duration_delta.setToolTip(tr("bar_duration_tooltip"))
+        toolbar2.addWidget(self.spin_bar_duration_delta)
+
+        self.btn_apply_bar_duration = QPushButton(tr("apply_bar_duration"))
+        self.btn_apply_bar_duration.setToolTip(tr("apply_bar_duration_tooltip"))
+        self.btn_apply_bar_duration.clicked.connect(self._apply_bar_duration_delta)
+        toolbar2.addWidget(self.btn_apply_bar_duration)
+
+        toolbar2.addSeparator()
+
         # 编辑风格选择
         toolbar2.addWidget(QLabel(" Style: "))
         self.cmb_edit_style = QComboBox()
@@ -497,6 +515,13 @@ class EditorWindow(QMainWindow):
         # 键盘拖拽选择音域 → 钢琴卷帘批量选择
         self.keyboard.sig_range_selected.connect(self.piano_roll.select_by_pitch_range)
 
+        # Bar selection: timeline → piano_roll
+        self.timeline.sig_bar_selection_changed.connect(self.piano_roll.set_selected_bars)
+        self.timeline.sig_drag_range.connect(self.piano_roll.set_drag_boundary)
+
+        # Notes changed → refresh key_list and timeline
+        self.piano_roll.sig_notes_changed.connect(self._on_notes_changed_refresh)
+
         # 按键列表开关
         self.chk_key_list.toggled.connect(self._on_key_list_toggled)
 
@@ -966,6 +991,41 @@ class EditorWindow(QMainWindow):
         # 重置 spinbox
         self.spin_duration_delta.setValue(0)
 
+    def _apply_bar_duration_delta(self):
+        """应用小节时值调整到选中小节内的音符"""
+        delta_ms = self.spin_bar_duration_delta.value()
+        if delta_ms == 0:
+            return
+        selected_bars = self.piano_roll.get_selected_bars()
+        if not selected_bars:
+            from PyQt6.QtWidgets import QMessageBox
+            QMessageBox.information(
+                self,
+                tr("no_bars_selected_title"),
+                tr("no_bars_selected_msg")
+            )
+            return
+        self.piano_roll.adjust_selected_bars_duration(delta_ms)
+        # 更新 key list
+        if self.chk_key_list.isChecked():
+            events = self.export_events()
+            self.key_list.set_events(events)
+            self.key_list.set_total_duration(self.piano_roll.total_duration)
+        # 更新 timeline duration
+        self.timeline.set_duration(self.piano_roll.total_duration)
+        # 重置 spinbox
+        self.spin_bar_duration_delta.setValue(0)
+
+    def _on_notes_changed_refresh(self):
+        """当音符变化时刷新 key_list 和 timeline"""
+        # 更新 key list
+        if self.chk_key_list.isChecked():
+            events = self.export_events()
+            self.key_list.set_events(events)
+            self.key_list.set_total_duration(self.piano_roll.total_duration)
+        # 更新 timeline duration
+        self.timeline.set_duration(self.piano_roll.total_duration)
+
     def _update_bar_lines(self):
         """更新钢琴卷帘的小节分隔线"""
         bpm = max(1, int(self.sp_bpm.value()))
diff --git a/LyreAutoPlayer/ui/editor/piano_roll.py b/LyreAutoPlayer/ui/editor/piano_roll.py
index c3b6bc0..2f8273a 100644
--- a/LyreAutoPlayer/ui/editor/piano_roll.py
+++ b/LyreAutoPlayer/ui/editor/piano_roll.py
@@ -13,7 +13,7 @@ from .note_item import NoteItem
 from .undo_commands import (
     AddNoteCommand, DeleteNotesCommand, MoveNotesCommand,
     TransposeCommand, QuantizeCommand, AutoTransposeCommand,
-    HumanizeCommand, ApplyJitterCommand
+    HumanizeCommand, ApplyJitterCommand, AdjustBarsDurationCommand
 )
 
 
@@ -87,6 +87,18 @@ class PianoRollWidget(QGraphicsView):
         # 量化分辨率 (秒)
         self._quantize_grid_size: float = 0.25  # 默认 1/4 拍 @120BPM
 
+        # Bar selection state (从 timeline 同步)
+        self._selected_bars: List[int] = []
+
+        # Drag boundary state (黄色竖线)
+        self._drag_boundary_start: float = 0.0  # 秒
+        self._drag_boundary_end: float = 0.0    # 秒
+        self._drag_boundary_active: bool = False
+
+        # Bar selection overlay items
+        self._bar_overlay_items: List = []
+        self._drag_line_items: List = []
+
         # 视图设置
         self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOn)
         self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOn)
@@ -1367,3 +1379,285 @@ class PianoRollWidget(QGraphicsView):
         self._clamp_scrollbar()
 
         self.sig_notes_changed.emit()
+
+    # ============== Bar Selection & Duration Adjustment ==============
+
+    def set_selected_bars(self, bar_numbers: List[int]):
+        """设置选中的小节并绘制覆盖层
+
+        Args:
+            bar_numbers: 选中的小节号列表 (从 0 开始)
+        """
+        self._selected_bars = bar_numbers[:]
+        self._update_bar_overlay()
+
+    def get_selected_bars(self) -> List[int]:
+        """获取当前选中的小节列表"""
+        return self._selected_bars[:]
+
+    def clear_selected_bars(self):
+        """清除小节选择"""
+        self._selected_bars.clear()
+        self._clear_bar_overlay()
+
+    def set_drag_boundary(self, start_sec: float, end_sec: float, active: bool):
+        """设置拖拽边界线 (黄色竖线)
+
+        Args:
+            start_sec: 起始时间 (秒)
+            end_sec: 结束时间 (秒)
+            active: 是否激活显示
+        """
+        self._drag_boundary_start = start_sec
+        self._drag_boundary_end = end_sec
+        self._drag_boundary_active = active
+        self._update_drag_lines()
+
+    def _clear_bar_overlay(self):
+        """清除小节选择覆盖层"""
+        for item in self._bar_overlay_items:
+            self.scene.removeItem(item)
+        self._bar_overlay_items.clear()
+
+    def _update_bar_overlay(self):
+        """更新小节选择覆盖层
+
+        注意: bar_num 从 timeline 传入，是 1-based (小节 1, 2, 3, ...)
+        转换为时间时需要使用 (bar_num - 1) * _bar_duration_sec
+        """
+        self._clear_bar_overlay()
+
+        if not self._selected_bars or self._bar_duration_sec <= 0:
+            return
+
+        scene_height = (self.NOTE_RANGE[1] - self.NOTE_RANGE[0] + 1) * self.pixels_per_note
+        overlay_color = QColor(255, 255, 0, 40)  # 半透明黄色
+
+        for bar_num in sorted(self._selected_bars):
+            # bar_num 是 1-based，转换为 0-based 计算时间
+            x_start = (bar_num - 1) * self._bar_duration_sec * self.pixels_per_second
+            width = self._bar_duration_sec * self.pixels_per_second
+
+            rect = QGraphicsRectItem(x_start, 0, width, scene_height)
+            rect.setBrush(QBrush(overlay_color))
+            rect.setPen(QPen(Qt.PenStyle.NoPen))
+            rect.setZValue(-5)  # 在网格之上，音符之下
+            rect.setAcceptedMouseButtons(Qt.MouseButton.NoButton)
+            self.scene.addItem(rect)
+            self._bar_overlay_items.append(rect)
+
+    def _clear_drag_lines(self):
+        """清除拖拽边界线"""
+        for item in self._drag_line_items:
+            self.scene.removeItem(item)
+        self._drag_line_items.clear()
+
+    def _update_drag_lines(self):
+        """更新拖拽边界线 (黄色竖线)"""
+        self._clear_drag_lines()
+
+        if not self._drag_boundary_active:
+            return
+
+        scene_height = (self.NOTE_RANGE[1] - self.NOTE_RANGE[0] + 1) * self.pixels_per_note
+        pen = QPen(QColor(255, 255, 0), 2)  # 黄色 2px
+
+        # 起始线
+        x1 = self._drag_boundary_start * self.pixels_per_second
+        line1 = self.scene.addLine(x1, 0, x1, scene_height, pen)
+        line1.setZValue(90)  # 在音符之上，播放头之下
+        line1.setAcceptedMouseButtons(Qt.MouseButton.NoButton)
+        self._drag_line_items.append(line1)
+
+        # 结束线
+        x2 = self._drag_boundary_end * self.pixels_per_second
+        line2 = self.scene.addLine(x2, 0, x2, scene_height, pen)
+        line2.setZValue(90)
+        line2.setAcceptedMouseButtons(Qt.MouseButton.NoButton)
+        self._drag_line_items.append(line2)
+
+    def adjust_selected_bars_duration(self, delta_ms: int):
+        """调整选中小节内音符的时值，并平移后续音符
+
+        时间拉伸/压缩语义：
+        - 选中的小节按连续区间分组（如 [1,2] 和 [5,6] 是两个区间）
+        - 每个区间内的音符按比例拉伸/压缩
+        - 后续区间和音符累计平移
+        - delta 按小节数量累计：total_delta = delta_sec * bar_count
+
+        音符归属判定：
+        - 使用区间重叠检测（音符时间区间与小节区间有交集）
+        - 不使用音符中心点
+
+        Args:
+            delta_ms: 每小节时值增量 (毫秒，正=拉伸，负=压缩)
+
+        注意: bar_num 是 1-based (小节 1, 2, 3, ...)
+        """
+        if not self._selected_bars or self._bar_duration_sec <= 0:
+            return
+
+        delta_sec_per_bar = delta_ms / 1000.0
+
+        # 将选中小节分组为连续区间
+        # 例如 [1, 2, 5, 6, 7] -> [[1, 2], [5, 6, 7]]
+        sorted_bars = sorted(self._selected_bars)
+        intervals = []  # [(first_bar, last_bar), ...]
+        if sorted_bars:
+            interval_start = sorted_bars[0]
+            interval_end = sorted_bars[0]
+            for bar in sorted_bars[1:]:
+                if bar == interval_end + 1:
+                    # 连续，扩展当前区间
+                    interval_end = bar
+                else:
+                    # 不连续，保存当前区间，开始新区间
+                    intervals.append((interval_start, interval_end))
+                    interval_start = bar
+                    interval_end = bar
+            intervals.append((interval_start, interval_end))
+
+        if not intervals:
+            return
+
+        # 收集所有音符的旧状态
+        all_notes_old_data = [{
+            "note": item.note,
+            "start": item.start_time,
+            "duration": item.duration,
+            "velocity": item.velocity,
+            "track": item.track,
+            "channel": getattr(item, 'channel', 0)
+        } for item in self.notes]
+
+        # 按起始时间排序音符（用于处理后续平移）
+        notes_by_start = sorted(self.notes, key=lambda n: n.start_time)
+
+        # 计算每个音符的新位置
+        # 使用字典存储：note_item -> new_data
+        note_updates = {}
+        cumulative_shift = 0.0  # 累计平移量
+
+        for interval_idx, (first_bar, last_bar) in enumerate(intervals):
+            # 计算此区间的时间范围 (bar_num 是 1-based)
+            interval_start_sec = (first_bar - 1) * self._bar_duration_sec
+            interval_end_sec = last_bar * self._bar_duration_sec
+
+            # 此区间包含的小节数
+            bar_count = last_bar - first_bar + 1
+
+            # 此区间的 delta
+            total_delta = delta_sec_per_bar * bar_count
+
+            # 原始时长和新时长
+            original_duration = interval_end_sec - interval_start_sec
+            new_duration = max(0.01, original_duration + total_delta)
+            scale = new_duration / original_duration if original_duration > 0 else 1.0
+
+            # 应用累计平移到此区间的起点
+            shifted_interval_start = interval_start_sec + cumulative_shift
+
+            # 找出与此区间重叠的音符（区间重叠检测）
+            for item in notes_by_start:
+                note_start = item.start_time
+                note_end = item.start_time + item.duration
+
+                # 跳过已处理的音符
+                if item in note_updates:
+                    continue
+
+                # 区间重叠检测：音符区间 [note_start, note_end) 与小节区间 [interval_start, interval_end) 有交集
+                # 注意：比较时需要考虑之前的累计平移
+                adjusted_note_start = note_start
+                if cumulative_shift != 0 and note_start >= interval_start_sec:
+                    # 此音符在当前或之后的区间，需要考虑累计平移
+                    pass  # 暂不调整，在下面处理
+
+                # 判断音符是否与原始区间重叠
+                if note_end > interval_start_sec and note_start < interval_end_sec:
+                    # 音符与此区间重叠，进行拉伸
+                    rel_start = note_start - interval_start_sec
+                    rel_end = rel_start + item.duration
+
+                    new_rel_start = rel_start * scale
+                    new_rel_end = rel_end * scale
+
+                    note_updates[item] = {
+                        "note": item.note,
+                        "start": shifted_interval_start + new_rel_start,
+                        "duration": max(0.01, new_rel_end - new_rel_start),
+                        "velocity": item.velocity,
+                        "track": item.track,
+                        "channel": getattr(item, 'channel', 0)
+                    }
+
+            # 更新累计平移量
+            cumulative_shift += (new_duration - original_duration)
+
+        # 处理未被任何区间覆盖的音符（在所有选中区间之后的音符需要平移）
+        last_interval_end = intervals[-1][1] * self._bar_duration_sec
+        for item in notes_by_start:
+            if item in note_updates:
+                continue
+
+            note_start = item.start_time
+
+            # 判断音符是否在所有选中区间之后
+            if note_start >= last_interval_end:
+                # 在最后一个区间之后，应用累计平移
+                note_updates[item] = {
+                    "note": item.note,
+                    "start": note_start + cumulative_shift,
+                    "duration": item.duration,
+                    "velocity": item.velocity,
+                    "track": item.track,
+                    "channel": getattr(item, 'channel', 0)
+                }
+            else:
+                # 在区间之间或之前，检查是否需要部分平移
+                # 找出此音符应该受到多少累计平移
+                shift_for_note = 0.0
+                temp_shift = 0.0
+                for first_bar, last_bar in intervals:
+                    interval_start_sec = (first_bar - 1) * self._bar_duration_sec
+                    interval_end_sec = last_bar * self._bar_duration_sec
+                    bar_count = last_bar - first_bar + 1
+                    total_delta = delta_sec_per_bar * bar_count
+                    original_dur = interval_end_sec - interval_start_sec
+                    new_dur = max(0.01, original_dur + total_delta)
+
+                    if note_start >= interval_end_sec:
+                        # 音符在此区间之后，累加此区间的平移
+                        temp_shift += (new_dur - original_dur)
+
+                if temp_shift != 0:
+                    note_updates[item] = {
+                        "note": item.note,
+                        "start": note_start + temp_shift,
+                        "duration": item.duration,
+                        "velocity": item.velocity,
+                        "track": item.track,
+                        "channel": getattr(item, 'channel', 0)
+                    }
+
+        if not note_updates:
+            return
+
+        # 构建 old 和 new 数据用于 undo 命令
+        old_notes_data = []
+        new_notes_data = []
+        for item, new_data in note_updates.items():
+            old_notes_data.append({
+                "note": item.note,
+                "start": item.start_time,
+                "duration": item.duration,
+                "velocity": item.velocity,
+                "track": item.track,
+                "channel": getattr(item, 'channel', 0)
+            })
+            new_notes_data.append(new_data)
+
+        # 使用 undo 命令
+        cmd = AdjustBarsDurationCommand(self, old_notes_data, new_notes_data)
+        self.undo_stack.push(cmd)
+        self.sig_notes_changed.emit()
diff --git a/LyreAutoPlayer/ui/editor/timeline.py b/LyreAutoPlayer/ui/editor/timeline.py
index 6f374fa..0d8a7e9 100644
--- a/LyreAutoPlayer/ui/editor/timeline.py
+++ b/LyreAutoPlayer/ui/editor/timeline.py
@@ -17,6 +17,8 @@ class TimelineWidget(QWidget):
     sig_seek = pyqtSignal(float)  # 点击跳转到指定时间 (秒)
     sig_bpm_changed = pyqtSignal(int)  # BPM 变化 (用于同步 spinbox)
     sig_select_range = pyqtSignal(float, float)  # 拖动选择范围 (start, end)
+    sig_bar_selection_changed = pyqtSignal(list)  # 选中小节列表变化 [bar_num, ...]
+    sig_drag_range = pyqtSignal(float, float, bool)  # 拖动边界线 (start, end, active)
 
     # 常量 - 颜色
     BG_COLOR = QColor(40, 40, 40)
@@ -30,11 +32,13 @@ class TimelineWidget(QWidget):
     PLAYHEAD_COLOR = QColor(255, 0, 0)
     SELECT_COLOR = QColor(80, 150, 255, 80)   # 选区背景 (半透明蓝)
     SELECT_BORDER = QColor(80, 150, 255)      # 选区边框
+    BAR_SELECTED_COLOR = QColor(255, 255, 200, 100)  # 选中小节背景 (半透明黄)
+    DRAG_LINE_COLOR = QColor(255, 255, 0)     # 拖动边界线 (黄色)
 
-    # 常量 - 布局 (+50% 高度)
-    HEIGHT = 75              # 总高度 (增加以容纳两行)
-    ROW_BAR = 30             # 上行高度 (小节/BPM)
-    ROW_TIME = 45            # 下行高度 (秒数)
+    # 常量 - 布局 (节拍行 +25%, 时间行 -25%)
+    HEIGHT = 72              # 总高度 = 38 + 34
+    ROW_BAR = 38             # 上行高度 (小节/BPM) = 30 * 1.25
+    ROW_TIME = 34            # 下行高度 (秒数) = 45 * 0.75
 
     def __init__(self, parent=None):
         super().__init__(parent)
@@ -65,6 +69,10 @@ class TimelineWidget(QWidget):
         self._drag_end: float = -1.0     # 拖动终点时间 (秒)
         self._is_dragging = False
 
+        # Ctrl+拖动选择小节状态
+        self._ctrl_dragging = False      # Ctrl+拖动模式
+        self._selected_bars: List[int] = []  # 选中小节编号列表
+
         self.setFixedHeight(self.HEIGHT)
         self.setMinimumWidth(100)
 
@@ -277,9 +285,20 @@ class TimelineWidget(QWidget):
         self._draw_time_row(painter, start_time, end_time, font_time)
 
         # ─────────────────────────────────────────────────────────────────────
-        # 选区 (拖动时绘制)
+        # 选中小节高亮 (Ctrl+拖动选中的小节)
+        # ─────────────────────────────────────────────────────────────────────
+        if self._selected_bars:
+            for bar_num in self._selected_bars:
+                bar_start, bar_end = self._get_bar_time_range(bar_num)
+                x1 = int((bar_start - start_time) * self.pixels_per_second)
+                x2 = int((bar_end - start_time) * self.pixels_per_second)
+                if x2 > x1 and x2 > 0 and x1 < self.width():
+                    painter.fillRect(x1, 0, x2 - x1, self.HEIGHT, self.BAR_SELECTED_COLOR)
+
+        # ─────────────────────────────────────────────────────────────────────
+        # 选区 (拖动时绘制，但 Ctrl+拖动时不显示蓝色选区)
         # ─────────────────────────────────────────────────────────────────────
-        if self._drag_start >= 0 and self._drag_end >= 0:
+        if self._drag_start >= 0 and self._drag_end >= 0 and not self._ctrl_dragging:
             sel_start = min(self._drag_start, self._drag_end)
             sel_end = max(self._drag_start, self._drag_end)
             x1 = int((sel_start - start_time) * self.pixels_per_second)
@@ -290,6 +309,20 @@ class TimelineWidget(QWidget):
                 painter.drawLine(x1, 0, x1, self.HEIGHT)
                 painter.drawLine(x2, 0, x2, self.HEIGHT)
 
+        # ─────────────────────────────────────────────────────────────────────
+        # Ctrl+拖动时的边界线 (黄线)
+        # ─────────────────────────────────────────────────────────────────────
+        if self._ctrl_dragging and self._drag_start >= 0 and self._drag_end >= 0:
+            raw_start = min(self._drag_start, self._drag_end)
+            raw_end = max(self._drag_start, self._drag_end)
+            snapped_start = self._snap_bar_floor(raw_start)
+            snapped_end = self._snap_bar_ceil(raw_end)
+            x1 = int((snapped_start - start_time) * self.pixels_per_second)
+            x2 = int((snapped_end - start_time) * self.pixels_per_second)
+            painter.setPen(QPen(self.DRAG_LINE_COLOR, 2))
+            painter.drawLine(x1, 0, x1, self.HEIGHT)
+            painter.drawLine(x2, 0, x2, self.HEIGHT)
+
         # ─────────────────────────────────────────────────────────────────────
         # 播放头 (贯穿两行)
         # ─────────────────────────────────────────────────────────────────────
@@ -523,44 +556,150 @@ class TimelineWidget(QWidget):
         # 超出最后小节，返回总时长
         return self.total_duration
 
+    def _get_bar_at_time(self, time_sec: float) -> int:
+        """获取指定时间所在的小节编号"""
+        bar_num = 1
+        for bn, bt in self._bar_times:
+            if bt > time_sec:
+                break
+            bar_num = bn
+        return bar_num
+
+    def _get_bars_in_range(self, start_time: float, end_time: float) -> List[int]:
+        """获取时间范围内的所有小节编号"""
+        bars = []
+        for bn, bt in self._bar_times:
+            # 获取此小节的结束时间
+            next_bt = self.total_duration
+            for nbn, nbt in self._bar_times:
+                if nbn == bn + 1:
+                    next_bt = nbt
+                    break
+            # 小节与范围有交集
+            if bt < end_time and next_bt > start_time:
+                bars.append(bn)
+        return bars
+
+    def _get_bar_time_range(self, bar_num: int) -> Tuple[float, float]:
+        """获取指定小节的时间范围 (start, end)"""
+        start_time = 0.0
+        end_time = self.total_duration
+        for i, (bn, bt) in enumerate(self._bar_times):
+            if bn == bar_num:
+                start_time = bt
+                # 找下一个小节的开始时间作为结束
+                if i + 1 < len(self._bar_times):
+                    end_time = self._bar_times[i + 1][1]
+                break
+        return start_time, end_time
+
+    def get_selected_bars(self) -> List[int]:
+        """获取选中的小节列表"""
+        return list(self._selected_bars)
+
+    def set_selected_bars(self, bars: List[int]):
+        """设置选中的小节列表"""
+        self._selected_bars = list(bars)
+        self.update()
+
+    def clear_selected_bars(self):
+        """清除选中的小节"""
+        if self._selected_bars:
+            self._selected_bars = []
+            self.sig_bar_selection_changed.emit([])
+            self.update()
+
     def mousePressEvent(self, event):
         """点击/开始拖动（不吸附，记录精确位置）"""
         if event.button() == Qt.MouseButton.LeftButton:
             x = event.position().x()
             time_sec = (x + self.scroll_offset) / self.pixels_per_second
             time_sec = max(0, min(time_sec, self.total_duration))
-            # 记录精确位置（不吸附）
-            self._drag_start = time_sec
-            self._drag_end = time_sec
-            self._is_dragging = True
+
+            # 检查是否按住 Ctrl 键
+            ctrl_held = event.modifiers() & Qt.KeyboardModifier.ControlModifier
+
+            if ctrl_held:
+                # Ctrl+左键: 小节选择模式
+                self._ctrl_dragging = True
+                self._drag_start = time_sec
+                self._drag_end = time_sec
+                # 发射拖动边界信号（黄线）
+                snapped_start = self._snap_bar_floor(time_sec)
+                snapped_end = self._snap_bar_ceil(time_sec)
+                self.sig_drag_range.emit(snapped_start, snapped_end, True)
+            else:
+                # 普通左键: 跳转/选区模式
+                self._ctrl_dragging = False
+                self._drag_start = time_sec
+                self._drag_end = time_sec
+                self._is_dragging = True
             self.update()
 
     def mouseMoveEvent(self, event):
         """拖动选区（实时显示原始位置，不吸附预览）"""
-        if self._is_dragging:
-            x = event.position().x()
-            time_sec = (x + self.scroll_offset) / self.pixels_per_second
-            time_sec = max(0, min(time_sec, self.total_duration))
+        x = event.position().x()
+        time_sec = (x + self.scroll_offset) / self.pixels_per_second
+        time_sec = max(0, min(time_sec, self.total_duration))
+
+        if self._ctrl_dragging:
+            # Ctrl+拖动: 小节选择模式
+            self._drag_end = time_sec
+            # 发射拖动边界信号（黄线）
+            raw_start = min(self._drag_start, self._drag_end)
+            raw_end = max(self._drag_start, self._drag_end)
+            snapped_start = self._snap_bar_floor(raw_start)
+            snapped_end = self._snap_bar_ceil(raw_end)
+            self.sig_drag_range.emit(snapped_start, snapped_end, True)
+            self.update()
+        elif self._is_dragging:
             self._drag_end = time_sec
             self.update()
 
     def mouseReleaseEvent(self, event):
         """结束拖动并发射选择信号"""
-        if event.button() == Qt.MouseButton.LeftButton and self._is_dragging:
-            self._is_dragging = False
-            raw_start = min(self._drag_start, self._drag_end)
-            raw_end = max(self._drag_start, self._drag_end)
-            if abs(raw_end - raw_start) < 0.01:
-                # 单击 → 精确跳转（不吸附）
-                self.sig_seek.emit(raw_start)
-            else:
-                # 拖动 → 选区（start 向下取整，end 向上取整）
+        if event.button() == Qt.MouseButton.LeftButton:
+            if self._ctrl_dragging:
+                # Ctrl+拖动结束: 小节选择
+                self._ctrl_dragging = False
+                raw_start = min(self._drag_start, self._drag_end)
+                raw_end = max(self._drag_start, self._drag_end)
                 snapped_start = self._snap_bar_floor(raw_start)
                 snapped_end = self._snap_bar_ceil(raw_end)
-                self.sig_select_range.emit(snapped_start, snapped_end)
-            self._drag_start = -1.0
-            self._drag_end = -1.0
-            self.update()
+
+                # 获取范围内的小节
+                new_bars = self._get_bars_in_range(snapped_start, snapped_end)
+
+                # 累加选择（不清除原有）
+                for bar in new_bars:
+                    if bar not in self._selected_bars:
+                        self._selected_bars.append(bar)
+                self._selected_bars.sort()
+
+                # 发射信号
+                self.sig_bar_selection_changed.emit(list(self._selected_bars))
+                # 隐藏黄线
+                self.sig_drag_range.emit(0, 0, False)
+
+                self._drag_start = -1.0
+                self._drag_end = -1.0
+                self.update()
+            elif self._is_dragging:
+                self._is_dragging = False
+                raw_start = min(self._drag_start, self._drag_end)
+                raw_end = max(self._drag_start, self._drag_end)
+                if abs(raw_end - raw_start) < 0.01:
+                    # 单击 → 精确跳转（不吸附），同时清除小节选择
+                    self.clear_selected_bars()
+                    self.sig_seek.emit(raw_start)
+                else:
+                    # 拖动 → 选区（start 向下取整，end 向上取整）
+                    snapped_start = self._snap_bar_floor(raw_start)
+                    snapped_end = self._snap_bar_ceil(raw_end)
+                    self.sig_select_range.emit(snapped_start, snapped_end)
+                self._drag_start = -1.0
+                self._drag_end = -1.0
+                self.update()
 
     def get_bpm_text(self) -> str:
         """获取当前 BPM 显示文本"""
diff --git a/LyreAutoPlayer/ui/editor/undo_commands.py b/LyreAutoPlayer/ui/editor/undo_commands.py
index 09d8bc7..63b2ed2 100644
--- a/LyreAutoPlayer/ui/editor/undo_commands.py
+++ b/LyreAutoPlayer/ui/editor/undo_commands.py
@@ -529,6 +529,55 @@ class AdjustDurationCommand(QUndoCommand):
                     item.duration = data["duration"]
                     break
 
+        pr._refresh_notes()
+        if pr.notes:
+            pr.total_duration = max(n.start_time + n.duration for n in pr.notes)
+
+
+class AdjustBarsDurationCommand(QUndoCommand):
+    """调整选中小节内音符的时值（时间拉伸/压缩）
+
+    - 选中的小节内所有音符按比例拉伸/压缩
+    - 选中小节之后的所有音符整体平移
+    """
+
+    def __init__(self, piano_roll, old_notes_data: list, new_notes_data: list, parent=None):
+        """
+        Args:
+            piano_roll: PianoRollWidget 实例
+            old_notes_data: 原始音符数据 [{note, start, duration, velocity, track, channel}, ...]
+            new_notes_data: 新音符数据（与 old_notes_data 一一对应）
+        """
+        super().__init__(parent)
+        self._piano_roll = weakref.ref(piano_roll)
+        self._old_notes_data = [d.copy() for d in old_notes_data]
+        self._new_notes_data = [d.copy() for d in new_notes_data]
+        self.setText(f"Adjust Bars Duration ({len(old_notes_data)} notes)")
+
+    def redo(self):
+        """执行/重做: 应用新的音符位置和时值"""
+        self._apply_notes_data(self._old_notes_data, self._new_notes_data)
+
+    def undo(self):
+        """撤销: 恢复原始音符位置和时值"""
+        self._apply_notes_data(self._new_notes_data, self._old_notes_data)
+
+    def _apply_notes_data(self, from_data: list, to_data: list):
+        """将音符从 from_data 状态更新到 to_data 状态"""
+        pr = self._piano_roll()
+        if not pr:
+            return
+
+        for from_d, to_d in zip(from_data, to_data):
+            for item in pr.notes:
+                if (item.note == from_d["note"] and
+                    abs(item.start_time - from_d["start"]) < 0.001 and
+                    abs(item.duration - from_d["duration"]) < 0.001):
+                    # 更新到新状态
+                    item.start_time = to_d["start"]
+                    item.duration = to_d["duration"]
+                    break
+
         pr._refresh_notes()
         if pr.notes:
             pr.total_duration = max(n.start_time + n.duration for n in pr.notes)
\ No newline at end of file
diff --git a/ops/ai/context/SESSION_SUMMARY.md b/ops/ai/context/SESSION_SUMMARY.md
index 473edb2..fa85fb8 100644
--- a/ops/ai/context/SESSION_SUMMARY.md
+++ b/ops/ai/context/SESSION_SUMMARY.md
@@ -1,7 +1,18 @@
-- 背景/目标: 使用 message-review 核对一系列 UI/播放改动摘要与代码一致性，重点关注 KeyListWidget 同步、自动翻页、Audio 勾选同步、i18n 菜单等问题。
-- 已完成: 多轮审计对照源码，确认多项修复已落地并指出残留风险；为每轮审计给出可直接发给 Claude 的修订提示词。
-- 关键修改: 仅审计未直接改代码；在当前 repo 中可见的改动包括 KeyListWidget 左侧宽度对齐、进度遍历更新与自动滚动参数、PianoRoll 自动翻页、编辑器工具栏拆分、菜单 i18n 使用 tr、主窗 effective_root 计算含八度偏移、root/octave/preset 实时同步、主窗→编辑器 Audio 勾选同步、ApplyJitterCommand 与抖动应用使用 QUndoStack。
-- 相关文件: LyreAutoPlayer/ui/editor/key_list_widget.py（KeyLabel 宽度、进度遍历、auto_scroll）、LyreAutoPlayer/ui/editor/piano_roll.py（播放头自动翻页）、LyreAutoPlayer/ui/editor/editor_window.py（菜单 i18n、工具栏换行、抖动应用）、LyreAutoPlayer/ui/editor/undo_commands.py（ApplyJitterCommand）、LyreAutoPlayer/main.py（effective_root 计算、键盘配置实时同步、Audio 同步）、LyreAutoPlayer/i18n/translations.py（apply_jitter 文案）。
-- 验证: 未运行测试或程序，仅代码审计。
-- 风险/待办: main.py 仍存在调用 _update_style_params_display 的残留风险（可能导致启动 AttributeError，需确认是否已删除）；自动翻页/进度变黑/Audio 同步等需要运行时验证；KeyList 与卷帘的对齐与滚动同步仍需人工确认。
-- 下一步: 手动运行应用验证 UI 对齐、自动翻页、进度变黑与 Audio 同步；如仍有崩溃则移除 _update_style_params_display 调用；必要时进一步调优播放头平滑度与同步细节。
+- 背景/目标:
+  处理用户新增需求与回归问题（小节选择/拉伸、拖拽黄线、时间轴行高调整、滚动同步），并对现有改动进行 message-review 审计与纠偏建议。
+- 已完成:
+  基于用户提供的变更审计报告与代码核查，定位关键风险并给出修复提示词；更新 session-summary 记录。
+- 关键修改:
+  无新的代码修改；本次仅审计并提出修正建议。
+- 相关文件:
+  - LyreAutoPlayer/ui/editor/piano_roll.py：发现小节编号 1-based 与现有公式不一致、非连续小节拉伸逻辑不正确、增量应按小节数累计、音符命中判定建议用区间重叠。
+  - LyreAutoPlayer/ui/editor/timeline.py：Ctrl 拖拽仍绘制蓝色选区；小节选择/拖拽信号已新增但需按需求调整。
+  - LyreAutoPlayer/ui/editor/editor_window.py：未选中小节提示为英文硬编码，建议改为 tr()；需监听 sig_notes_changed 统一刷新 key_list/timeline（先前建议）。
+  - LyreAutoPlayer/i18n/translations.py：建议补充小节相关提示的中文键值。
+  - LyreAutoPlayer/ui/editor/undo_commands.py：新增 AdjustBarsDurationCommand 已存在（依赖 weakref 已补）。
+- 验证:
+  未运行测试；用户提供了运行时错误与截图作为证据。
+- 风险/待办:
+  1) 修复小节编号 off-by-one，避免选中/拉伸错位；2) 支持 Ctrl 多选非连续小节分段拉伸；3) 增量按小节数累计；4) Ctrl 拖拽仅显示黄线，去掉蓝色选区；5) 提示文案 i18n。
+- 下一步:
+  让 Claude 按提示词实施修复，并回归验证：Ctrl+拖拽多选、单击精确跳转、黄线显示、选中小节反色、按小节拉伸/压缩与滚动同步。
diff --git a/ops/ai/tasks/20260103-midi-editor-pipeline/evidence/diff.patch b/ops/ai/tasks/20260103-midi-editor-pipeline/evidence/diff.patch
index a167541..58602a8 100644
--- a/ops/ai/tasks/20260103-midi-editor-pipeline/evidence/diff.patch
+++ b/ops/ai/tasks/20260103-midi-editor-pipeline/evidence/diff.patch
@@ -1,2671 +0,0 @@
-diff --git a/LyreAutoPlayer/i18n/translations.py b/LyreAutoPlayer/i18n/translations.py
-index b3467d6..1525ef2 100644
---- a/LyreAutoPlayer/i18n/translations.py
-+++ b/LyreAutoPlayer/i18n/translations.py
-@@ -235,4 +235,15 @@ TRANSLATIONS = {
-     },
-     "scope_selected": {LANG_EN: "selected", LANG_ZH: "选中的"},
-     "scope_all": {LANG_EN: "all", LANG_ZH: "全部"},
-+    # Duration adjustment
-+    "duration_label": {LANG_EN: " Duration: ", LANG_ZH: " 时值: "},
-+    "duration_tooltip": {
-+        LANG_EN: "Duration adjustment in milliseconds (step: 50ms)",
-+        LANG_ZH: "时值调整（毫秒，步进 50ms）",
-+    },
-+    "apply_duration": {LANG_EN: "Apply", LANG_ZH: "应用"},
-+    "apply_duration_tooltip": {
-+        LANG_EN: "Apply duration change to selected notes",
-+        LANG_ZH: "将时值变化应用到选中音符",
-+    },
- }
-diff --git a/LyreAutoPlayer/settings.json b/LyreAutoPlayer/settings.json
-index 689072b..2db0a3c 100644
---- a/LyreAutoPlayer/settings.json
-+++ b/LyreAutoPlayer/settings.json
-@@ -19,7 +19,7 @@
-   "input_style": "mechanical",
-   "enable_diagnostics": false,
-   "soundfont_path": "C:\\soundfonts\\FluidR3_GM.sf2",
--  "last_midi_path": "d:\\dw11\\piano\\lyreautoplayer\\midi-change\\city-of-stars-星光之城-爱乐之城-原神风物之诗琴谱-原琴谱_custom.mid",
-+  "last_midi_path": "D:/dw11/piano/LyreAutoPlayer/midi/Counting-Stars-C调简单版.mid",
-   "input_manager": {},
-   "error_config": {
-     "enabled": false,
-diff --git a/LyreAutoPlayer/ui/editor/editor_window.py b/LyreAutoPlayer/ui/editor/editor_window.py
-index 87e8375..36357c7 100644
---- a/LyreAutoPlayer/ui/editor/editor_window.py
-+++ b/LyreAutoPlayer/ui/editor/editor_window.py
-@@ -17,7 +17,8 @@ from datetime import datetime
- from PyQt6.QtWidgets import (
-     QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
-     QToolBar, QSlider, QLabel, QFileDialog, QMessageBox,
--    QSplitter, QScrollBar, QComboBox, QSpinBox, QCheckBox
-+    QSplitter, QScrollBar, QComboBox, QSpinBox, QCheckBox,
-+    QPushButton
- )
- from PyQt6.QtGui import QAction, QIcon, QShortcut, QKeySequence
- from PyQt6.QtCore import Qt, QTimer, pyqtSignal
-@@ -300,6 +301,24 @@ class EditorWindow(QMainWindow):
- 
-         toolbar2.addSeparator()
- 
-+        # 时值调整控件
-+        toolbar2.addWidget(QLabel(tr("duration_label")))
-+        self.spin_duration_delta = QSpinBox()
-+        self.spin_duration_delta.setRange(-5000, 5000)
-+        self.spin_duration_delta.setSingleStep(50)
-+        self.spin_duration_delta.setValue(0)
-+        self.spin_duration_delta.setSuffix(" ms")
-+        self.spin_duration_delta.setFixedWidth(90)
-+        self.spin_duration_delta.setToolTip(tr("duration_tooltip"))
-+        toolbar2.addWidget(self.spin_duration_delta)
-+
-+        self.btn_apply_duration = QPushButton(tr("apply_duration"))
-+        self.btn_apply_duration.setToolTip(tr("apply_duration_tooltip"))
-+        self.btn_apply_duration.clicked.connect(self._apply_duration_delta)
-+        toolbar2.addWidget(self.btn_apply_duration)
-+
-+        toolbar2.addSeparator()
-+
-         # 编辑风格选择
-         toolbar2.addWidget(QLabel(" Style: "))
-         self.cmb_edit_style = QComboBox()
-@@ -450,9 +469,11 @@ class EditorWindow(QMainWindow):
-         self.playback_timer.timeout.connect(self._update_playback)
-         self.timeline.sig_seek.connect(self.on_seek)
-         self.cmb_edit_style.currentTextChanged.connect(self._on_edit_style_changed)
-+        self.cmb_input_style.currentTextChanged.connect(self._on_input_style_changed)
-         self.cmb_quantize.currentTextChanged.connect(self._on_quantize_changed)
-         self.sp_bpm.valueChanged.connect(self._on_bpm_changed)
-         self.timeline.sig_bpm_changed.connect(self._on_timeline_bpm_changed)
-+        self.timeline.sig_select_range.connect(self._on_timeline_select_range)
-         self.sp_octave_shift.valueChanged.connect(self._on_octave_shift_changed)
- 
-         # 同步滚动
-@@ -462,14 +483,10 @@ class EditorWindow(QMainWindow):
-         self.piano_roll.verticalScrollBar().valueChanged.connect(
-             lambda v: self.keyboard.set_scroll_offset(v)
-         )
--        # 按键进度窗水平滚动同步
-+        # 按键进度窗水平滚动同步（单向：piano_roll → key_list）
-         self.piano_roll.horizontalScrollBar().valueChanged.connect(
-             lambda v: self.key_list.set_scroll_offset(v)
-         )
--        # 双向同步：按键进度窗滚动也同步到 PianoRoll
--        self.key_list.sig_scroll_changed.connect(
--            lambda v: self._sync_scroll_from_key_list(v)
--        )
- 
-         # 同步缩放 (Ctrl+滚轮 → 时间轴 + 滑条 + 按键进度窗)
-         self.piano_roll.sig_zoom_changed.connect(self._on_piano_roll_zoom)
-@@ -495,6 +512,7 @@ class EditorWindow(QMainWindow):
-             # 更新按键列表内容
-             events = self.export_events()
-             self.key_list.set_events(events)
-+            self.key_list.set_total_duration(self.piano_roll.total_duration)
-             # 同步缩放
-             self.key_list.set_scale(self.piano_roll.pixels_per_second)
-         else:
-@@ -599,6 +617,7 @@ class EditorWindow(QMainWindow):
- 
-             # 更新按键列表
-             self.key_list.set_events(events_list)
-+            self.key_list.set_total_duration(self.piano_roll.total_duration)
- 
-         except Exception as e:
-             QMessageBox.critical(self, "Error", f"Failed to load MIDI:\n{e}")
-@@ -747,6 +766,12 @@ class EditorWindow(QMainWindow):
-         """编辑风格变化"""
-         self.edit_style = text
- 
-+    def _on_input_style_changed(self, text: str):
-+        """输入风格变化 → 自动应用 jitter（仅当有选中音符时）"""
-+        selected = [item for item in self.piano_roll.notes if item.isSelected()]
-+        if selected:
-+            self._apply_input_style_jitter()
-+
-     def _on_quantize_changed(self, text: str):
-         """量化分辨率变化
- 
-@@ -801,6 +826,10 @@ class EditorWindow(QMainWindow):
-         # Notify main window of BPM change
-         self.bpm_changed.emit(bpm)
- 
-+    def _on_timeline_select_range(self, start: float, end: float):
-+        """时间轴拖动选区 → 批量选中音符"""
-+        self.piano_roll.select_by_filter(time_range=(start, end))
-+
-     def _on_octave_shift_changed(self, value: int):
-         """八度平移变化 - 实际修改音符数据
- 
-@@ -828,6 +857,7 @@ class EditorWindow(QMainWindow):
-         if self.chk_key_list.isChecked():
-             events = self.export_events()
-             self.key_list.set_events(events)
-+            self.key_list.set_total_duration(self.piano_roll.total_duration)
- 
-         # Log the change
-         self.statusBar().showMessage(
-@@ -902,6 +932,7 @@ class EditorWindow(QMainWindow):
-         if self.chk_key_list.isChecked():
-             events = self.export_events()
-             self.key_list.set_events(events)
-+            self.key_list.set_total_duration(self.piano_roll.total_duration)
- 
-         # Emit notes changed for tracking
-         self.piano_roll.sig_notes_changed.emit()
-@@ -920,6 +951,21 @@ class EditorWindow(QMainWindow):
-             5000
-         )
- 
-+    def _apply_duration_delta(self):
-+        """应用时值调整到选中音符"""
-+        delta_ms = self.spin_duration_delta.value()
-+        if delta_ms == 0:
-+            return
-+        delta_sec = delta_ms / 1000.0
-+        self.piano_roll.adjust_selected_duration(delta_sec)
-+        # 更新 key list
-+        if self.chk_key_list.isChecked():
-+            events = self.export_events()
-+            self.key_list.set_events(events)
-+            self.key_list.set_total_duration(self.piano_roll.total_duration)
-+        # 重置 spinbox
-+        self.spin_duration_delta.setValue(0)
-+
-     def _update_bar_lines(self):
-         """更新钢琴卷帘的小节分隔线"""
-         bpm = max(1, int(self.sp_bpm.value()))
-@@ -1490,14 +1536,6 @@ class EditorWindow(QMainWindow):
-         if self.chk_key_list.isChecked():
-             self.key_list.set_scale(float(value))
- 
--    def _sync_scroll_from_key_list(self, value: int):
--        """从按键进度窗同步水平滚动到 PianoRollWidget"""
--        self.piano_roll.horizontalScrollBar().blockSignals(True)
--        self.piano_roll.horizontalScrollBar().setValue(value)
--        self.piano_roll.horizontalScrollBar().blockSignals(False)
--        # 同步时间轴
--        self.timeline.set_scroll_offset(value)
--
-     def _on_piano_roll_zoom(self, pixels_per_second: float):
-         """缩放变化 (来自 Ctrl+滚轮)"""
-         # 同步时间轴
-diff --git a/LyreAutoPlayer/ui/editor/key_list_widget.py b/LyreAutoPlayer/ui/editor/key_list_widget.py
-index 49eb4d0..46ad840 100644
---- a/LyreAutoPlayer/ui/editor/key_list_widget.py
-+++ b/LyreAutoPlayer/ui/editor/key_list_widget.py
-@@ -120,6 +120,7 @@ class KeyProgressWidget(QGraphicsView):
-         self._layout: KeyboardLayout = LAYOUT_21KEY
-         self.pixels_per_second = 100.0
-         self.row_height = self.ROW_HEIGHT
-+        self._total_duration = 0.0  # 总时长（从 piano_roll 同步）
- 
-         # 播放头
-         self._playhead: Optional[QGraphicsLineItem] = None
-@@ -127,7 +128,7 @@ class KeyProgressWidget(QGraphicsView):
-         self._current_bar_index = -1
- 
-         # 视图设置
--        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOn)
-+        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # 只跟随 piano_roll
-         self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
-         self.setRenderHint(QPainter.RenderHint.Antialiasing, False)
-         self.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignTop)
-@@ -158,12 +159,7 @@ class KeyProgressWidget(QGraphicsView):
-             }
-         """)
- 
--        # 连接滚动信号
--        self.horizontalScrollBar().valueChanged.connect(self._on_hscroll)
--
--    def _on_hscroll(self, value: int):
--        """水平滚动变化"""
--        self.sig_scroll_changed.emit(value)
-+        # 不连接水平滚动信号，只跟随 piano_roll
- 
-     def set_scroll_offset(self, offset: int):
-         """设置水平滚动位置（从 PianoRollWidget 同步）"""
-@@ -195,6 +191,11 @@ class KeyProgressWidget(QGraphicsView):
-         self.row_height = height
-         self._update_all_geometry()
- 
-+    def set_total_duration(self, duration: float):
-+        """设置总时长（从 PianoRollWidget 同步）"""
-+        self._total_duration = duration
-+        self._update_scene_size()
-+
-     def _rebuild_key_rows(self):
-         """重建按键行列表"""
-         self._key_rows.clear()
-@@ -277,11 +278,12 @@ class KeyProgressWidget(QGraphicsView):
-         if not self._key_rows:
-             return
- 
--        # 计算场景宽度
-+        # 计算场景宽度（考虑 total_duration）
-         if self._events:
-             max_time = max(e["time"] + e.get("duration", 0.1) for e in self._events)
-         else:
-             max_time = 10.0
-+        max_time = max(max_time, self._total_duration)
-         scene_width = max(max_time * self.pixels_per_second + 200, 800)
- 
-         pen = QPen(self.GRID_COLOR, 1)
-@@ -308,6 +310,7 @@ class KeyProgressWidget(QGraphicsView):
-             max_time = max(e["time"] + e.get("duration", 0.1) for e in self._events)
-         else:
-             max_time = 10.0
-+        max_time = max(max_time, self._total_duration)
- 
-         # 使用与 PianoRoll 相同的计算方式：max(content_width, viewport_width)
-         content_width = max_time * self.pixels_per_second + 100  # +100 与 piano_roll 一致
-@@ -534,6 +537,10 @@ class KeyListWidget(QWidget):
-         """设置水平滚动位置"""
-         self.progress_view.set_scroll_offset(offset)
- 
-+    def set_total_duration(self, duration: float):
-+        """设置总时长"""
-+        self.progress_view.set_total_duration(duration)
-+
-     def update_playback_time(self, current_time: float, auto_scroll: bool = False):
-         """更新播放时间
- 
-diff --git a/LyreAutoPlayer/ui/editor/piano_roll.py b/LyreAutoPlayer/ui/editor/piano_roll.py
-index b92489f..c3b6bc0 100644
---- a/LyreAutoPlayer/ui/editor/piano_roll.py
-+++ b/LyreAutoPlayer/ui/editor/piano_roll.py
-@@ -1210,6 +1210,28 @@ class PianoRollWidget(QGraphicsView):
-         end = max(item.start_time + item.duration for item in selected)
-         return (start, end)
- 
-+    def adjust_selected_duration(self, delta_sec: float):
-+        """调整选中音符的时值
-+
-+        Args:
-+            delta_sec: 时值增量（秒，可正可负）
-+        """
-+        from .undo_commands import AdjustDurationCommand
-+
-+        selected = [item for item in self.notes if item.isSelected()]
-+        if not selected:
-+            return
-+
-+        notes_data = [{
-+            "note": item.note,
-+            "start": item.start_time,
-+            "duration": item.duration
-+        } for item in selected]
-+
-+        cmd = AdjustDurationCommand(self, notes_data, delta_sec)
-+        self.undo_stack.push(cmd)
-+        self.sig_notes_changed.emit()
-+
-     def select_by_pitch_range(self, low_note: int, high_note: int):
-         """按音域范围选择音符（保留现有时间范围过滤）
- 
-diff --git a/LyreAutoPlayer/ui/editor/timeline.py b/LyreAutoPlayer/ui/editor/timeline.py
-index 133f515..6f374fa 100644
---- a/LyreAutoPlayer/ui/editor/timeline.py
-+++ b/LyreAutoPlayer/ui/editor/timeline.py
-@@ -16,6 +16,7 @@ class TimelineWidget(QWidget):
- 
-     sig_seek = pyqtSignal(float)  # 点击跳转到指定时间 (秒)
-     sig_bpm_changed = pyqtSignal(int)  # BPM 变化 (用于同步 spinbox)
-+    sig_select_range = pyqtSignal(float, float)  # 拖动选择范围 (start, end)
- 
-     # 常量 - 颜色
-     BG_COLOR = QColor(40, 40, 40)
-@@ -27,6 +28,8 @@ class TimelineWidget(QWidget):
-     BEAT_LINE_COLOR = QColor(100, 100, 120)   # 拍线 (淡蓝灰)
-     BPM_COLOR = QColor(255, 180, 80)          # BPM 文字 (橙色)
-     PLAYHEAD_COLOR = QColor(255, 0, 0)
-+    SELECT_COLOR = QColor(80, 150, 255, 80)   # 选区背景 (半透明蓝)
-+    SELECT_BORDER = QColor(80, 150, 255)      # 选区边框
- 
-     # 常量 - 布局 (+50% 高度)
-     HEIGHT = 75              # 总高度 (增加以容纳两行)
-@@ -57,6 +60,11 @@ class TimelineWidget(QWidget):
-         self._tempo_events_tick: List[Tuple[int, int]] = [(0, 500000)]
-         self._time_sig_events_tick: List[Tuple[int, int, int]] = [(0, 4, 4)]
- 
-+        # 拖动选择状态
-+        self._drag_start: float = -1.0   # 拖动起点时间 (秒)
-+        self._drag_end: float = -1.0     # 拖动终点时间 (秒)
-+        self._is_dragging = False
-+
-         self.setFixedHeight(self.HEIGHT)
-         self.setMinimumWidth(100)
- 
-@@ -268,6 +276,20 @@ class TimelineWidget(QWidget):
-         # ─────────────────────────────────────────────────────────────────────
-         self._draw_time_row(painter, start_time, end_time, font_time)
- 
-+        # ─────────────────────────────────────────────────────────────────────
-+        # 选区 (拖动时绘制)
-+        # ─────────────────────────────────────────────────────────────────────
-+        if self._drag_start >= 0 and self._drag_end >= 0:
-+            sel_start = min(self._drag_start, self._drag_end)
-+            sel_end = max(self._drag_start, self._drag_end)
-+            x1 = int((sel_start - start_time) * self.pixels_per_second)
-+            x2 = int((sel_end - start_time) * self.pixels_per_second)
-+            if x2 > x1:
-+                painter.fillRect(x1, 0, x2 - x1, self.HEIGHT, self.SELECT_COLOR)
-+                painter.setPen(QPen(self.SELECT_BORDER, 1))
-+                painter.drawLine(x1, 0, x1, self.HEIGHT)
-+                painter.drawLine(x2, 0, x2, self.HEIGHT)
-+
-         # ─────────────────────────────────────────────────────────────────────
-         # 播放头 (贯穿两行)
-         # ─────────────────────────────────────────────────────────────────────
-@@ -479,13 +501,66 @@ class TimelineWidget(QWidget):
- 
-             t += minor_interval
- 
-+    def _snap_bar_floor(self, time_sec: float) -> float:
-+        """将时间向下取整到小节起点"""
-+        if not self._bar_times:
-+            return time_sec
-+        best_t = 0.0
-+        for _, t in self._bar_times:
-+            if t <= time_sec:
-+                best_t = t
-+            else:
-+                break
-+        return best_t
-+
-+    def _snap_bar_ceil(self, time_sec: float) -> float:
-+        """将时间向上取整到小节终点"""
-+        if not self._bar_times:
-+            return time_sec
-+        for _, t in self._bar_times:
-+            if t >= time_sec:
-+                return t
-+        # 超出最后小节，返回总时长
-+        return self.total_duration
-+
-     def mousePressEvent(self, event):
--        """点击跳转"""
-+        """点击/开始拖动（不吸附，记录精确位置）"""
-         if event.button() == Qt.MouseButton.LeftButton:
-             x = event.position().x()
-             time_sec = (x + self.scroll_offset) / self.pixels_per_second
-             time_sec = max(0, min(time_sec, self.total_duration))
--            self.sig_seek.emit(time_sec)
-+            # 记录精确位置（不吸附）
-+            self._drag_start = time_sec
-+            self._drag_end = time_sec
-+            self._is_dragging = True
-+            self.update()
-+
-+    def mouseMoveEvent(self, event):
-+        """拖动选区（实时显示原始位置，不吸附预览）"""
-+        if self._is_dragging:
-+            x = event.position().x()
-+            time_sec = (x + self.scroll_offset) / self.pixels_per_second
-+            time_sec = max(0, min(time_sec, self.total_duration))
-+            self._drag_end = time_sec
-+            self.update()
-+
-+    def mouseReleaseEvent(self, event):
-+        """结束拖动并发射选择信号"""
-+        if event.button() == Qt.MouseButton.LeftButton and self._is_dragging:
-+            self._is_dragging = False
-+            raw_start = min(self._drag_start, self._drag_end)
-+            raw_end = max(self._drag_start, self._drag_end)
-+            if abs(raw_end - raw_start) < 0.01:
-+                # 单击 → 精确跳转（不吸附）
-+                self.sig_seek.emit(raw_start)
-+            else:
-+                # 拖动 → 选区（start 向下取整，end 向上取整）
-+                snapped_start = self._snap_bar_floor(raw_start)
-+                snapped_end = self._snap_bar_ceil(raw_end)
-+                self.sig_select_range.emit(snapped_start, snapped_end)
-+            self._drag_start = -1.0
-+            self._drag_end = -1.0
-+            self.update()
- 
-     def get_bpm_text(self) -> str:
-         """获取当前 BPM 显示文本"""
-diff --git a/LyreAutoPlayer/ui/editor/undo_commands.py b/LyreAutoPlayer/ui/editor/undo_commands.py
-index 08cf4cc..09d8bc7 100644
---- a/LyreAutoPlayer/ui/editor/undo_commands.py
-+++ b/LyreAutoPlayer/ui/editor/undo_commands.py
-@@ -4,6 +4,7 @@ Undo Commands - 撤销/重做命令类
- Phase 3: 实现 QUndoCommand 子类用于各种编辑操作
- """
- import random
-+import weakref
- from typing import List, TYPE_CHECKING
- from PyQt6.QtGui import QUndoCommand
- 
-@@ -478,5 +479,56 @@ class ApplyJitterCommand(QUndoCommand):
-         pr._refresh_notes()
- 
-         # 更新总时长
-+        if pr.notes:
-+            pr.total_duration = max(n.start_time + n.duration for n in pr.notes)
-+
-+
-+class AdjustDurationCommand(QUndoCommand):
-+    """调整选中音符时值"""
-+
-+    def __init__(self, piano_roll, notes_data: list, delta_sec: float, parent=None):
-+        """
-+        Args:
-+            piano_roll: PianoRollWidget 实例
-+            notes_data: 选中音符数据 [{note, start, duration}, ...]
-+            delta_sec: 时值增量（秒，可正可负）
-+        """
-+        super().__init__(parent)
-+        self._piano_roll = weakref.ref(piano_roll)
-+        self._notes_data = notes_data
-+        self._delta_sec = delta_sec
-+        self.setText(f"Adjust Duration {delta_sec:+.3f}s")
-+
-+    def redo(self):
-+        pr = self._piano_roll()
-+        if not pr:
-+            return
-+
-+        for data in self._notes_data:
-+            for item in pr.notes:
-+                if (item.note == data["note"] and
-+                    abs(item.start_time - data["start"]) < 0.001 and
-+                    abs(item.duration - data["duration"]) < 0.001):
-+                    new_dur = max(0.01, item.duration + self._delta_sec)
-+                    item.duration = new_dur
-+                    break
-+
-+        pr._refresh_notes()
-+        if pr.notes:
-+            pr.total_duration = max(n.start_time + n.duration for n in pr.notes)
-+
-+    def undo(self):
-+        pr = self._piano_roll()
-+        if not pr:
-+            return
-+
-+        for data in self._notes_data:
-+            for item in pr.notes:
-+                if (item.note == data["note"] and
-+                    abs(item.start_time - data["start"]) < 0.001):
-+                    item.duration = data["duration"]
-+                    break
-+
-+        pr._refresh_notes()
-         if pr.notes:
-             pr.total_duration = max(n.start_time + n.duration for n in pr.notes)
-\ No newline at end of file
-diff --git a/ops/ai/tasks/20260103-midi-editor-pipeline/evidence/diff.patch b/ops/ai/tasks/20260103-midi-editor-pipeline/evidence/diff.patch
-index e0810ab..132761d 100644
---- a/ops/ai/tasks/20260103-midi-editor-pipeline/evidence/diff.patch
-+++ b/ops/ai/tasks/20260103-midi-editor-pipeline/evidence/diff.patch
-@@ -1,2167 +0,0 @@
--diff --git a/LyreAutoPlayer/i18n/translations.py b/LyreAutoPlayer/i18n/translations.py
--index f450db6..b3467d6 100644
----- a/LyreAutoPlayer/i18n/translations.py
--+++ b/LyreAutoPlayer/i18n/translations.py
--@@ -198,4 +198,41 @@ TRANSLATIONS = {
--     "original_file": {LANG_EN: "Original (原始文件)", LANG_ZH: "原始文件"},
--     "select_version": {LANG_EN: "Select Version", LANG_ZH: "选择版本"},
--     "select_version_prompt": {LANG_EN: "Select version to open:", LANG_ZH: "选择要打开的版本:"},
--+    # Strict Mode / Auto-Pause
--+    "strict_mode_group": {LANG_EN: "Strict Mode / Auto-Pause", LANG_ZH: "严格跟谱 / 自动暂停"},
--+    "strict_mode": {LANG_EN: "Strict Mode", LANG_ZH: "严格跟谱"},
--+    "strict_mode_hint": {
--+        LANG_EN: "Forces mechanical input, speed=1.0, MIDI duration, disables errors/8-bar",
--+        LANG_ZH: "强制机械输入、速度=1.0、使用MIDI时值，禁用失误/8小节风格",
--+    },
--+    "pause_every_bars": {LANG_EN: "Auto Pause", LANG_ZH: "自动暂停"},
--+    "auto_resume_countdown": {LANG_EN: "Resume Countdown", LANG_ZH: "恢复倒计时"},
--+    "press_f5_continue": {LANG_EN: "Press F5 to continue", LANG_ZH: "按 F5 继续"},
--+    # Editor Key List Widget
--+    "key_sequence": {LANG_EN: "Key Sequence", LANG_ZH: "按键序列"},
--+    "show_key_list": {LANG_EN: "Key List", LANG_ZH: "按键列表"},
--+    # Editor controls
--+    "editor_octave_shift": {LANG_EN: "Octave", LANG_ZH: "八度"},
--+    "editor_input_style": {LANG_EN: "Style", LANG_ZH: "风格"},
--+    "editor_pause_bars": {LANG_EN: "Pause Bars", LANG_ZH: "暂停间隔"},
--+    "editor_auto_resume": {LANG_EN: "Auto Resume", LANG_ZH: "自动恢复"},
--+    # Editor humanization / input style jitter
--+    "apply_jitter": {LANG_EN: "Apply Input Style Jitter (Humanize)", LANG_ZH: "应用输入风格抖动 (人性化)"},
--+    "apply_jitter_tooltip": {
--+        LANG_EN: "Apply timing jitter from selected input style to notes",
--+        LANG_ZH: "将所选输入风格的时序抖动应用到音符",
--+    },
--+    "style_not_found": {LANG_EN: "Style not found", LANG_ZH: "风格未找到"},
--+    "style_not_found_msg": {LANG_EN: "Style '{name}' not found in registry.", LANG_ZH: "风格 '{name}' 未在注册表中找到。"},
--+    "style_no_variation": {
--+        LANG_EN: "Style '{name}' has no timing variation (mechanical).\nChoose a different style for humanization.",
--+        LANG_ZH: "风格 '{name}' 没有时序变化（机械）。\n请选择其他风格进行人性化处理。",
--+    },
--+    "no_notes_to_jitter": {LANG_EN: "No notes to apply jitter to.", LANG_ZH: "没有可应用抖动的音符。"},
--+    "jitter_applied": {
--+        LANG_EN: "Applied '{style}' jitter to {count} {scope} notes (timing: {min_offset}~{max_offset}ms, duration: ±{duration_pct:.0f}%)",
--+        LANG_ZH: "已将 '{style}' 抖动应用到 {count} 个{scope}音符 (时序: {min_offset}~{max_offset}ms, 时值: ±{duration_pct:.0f}%)",
--+    },
--+    "scope_selected": {LANG_EN: "selected", LANG_ZH: "选中的"},
--+    "scope_all": {LANG_EN: "all", LANG_ZH: "全部"},
-- }
--diff --git a/LyreAutoPlayer/main.py b/LyreAutoPlayer/main.py
--index 2650f5d..5d84bb5 100644
----- a/LyreAutoPlayer/main.py
--+++ b/LyreAutoPlayer/main.py
--@@ -146,8 +146,7 @@ from ui.mixins import (
-- 
-- # Import Tab Builders for UI construction
-- from ui.tab_builders import (
---    build_main_tab, build_keyboard_tab, build_shortcuts_tab,
---    build_style_tab, build_errors_tab
--+    build_main_tab, build_keyboard_tab, build_shortcuts_tab
-- )
-- 
-- 
--@@ -183,6 +182,7 @@ class MainWindow(
--         self.diagnostics_window: Optional[DiagnosticsWindow] = None
--         self.editor_window: Optional[EditorWindow] = None
--         self._current_input_style = "mechanical"
--+        self._strict_mode = True  # Strict mode default ON
-- 
--         # Playback progress tracking (for floating controller)
--         self.current_time: float = 0.0
--@@ -192,9 +192,12 @@ class MainWindow(
--         self.init_ui()
--         self.apply_language()
--         self.refresh_windows()
---        self._update_style_params_display(self._current_input_style)  # Initialize style tab params
--         self.show_init_messages()
-- 
--+        # Apply initial strict mode state (disables controls when ON)
--+        if self._strict_mode and hasattr(self, 'chk_strict_mode'):
--+            self._on_strict_mode_changed(Qt.CheckState.Checked.value)
--+
--     def init_ui(self):
--         self.resize(950, 680)
--         layout = QVBoxLayout(self)
--@@ -225,15 +228,10 @@ class MainWindow(
--         layout.addWidget(self.tabs)
-- 
--         # Build tabs using tab_builders (Phase 2 modularization)
--+        # Note: Input Style and Error tabs removed - settings moved to Editor
--         self.tabs.addTab(build_main_tab(self), "Main")
--         self.tabs.addTab(build_keyboard_tab(self), "Keyboard")
--         self.tabs.addTab(build_shortcuts_tab(self), "Shortcuts")
---        self.tabs.addTab(build_style_tab(self), "Input Style")
---        self.tabs.addTab(build_errors_tab(self), tr("tab_errors", self.lang))
---
---        # --- REMOVED: Tab construction code moved to ui/tab_builders.py ---
---        # See: build_main_tab, build_keyboard_tab, build_shortcuts_tab,
---        #      build_style_tab, build_errors_tab
-- 
--         # Connect signals to slots (for thread-safe global hotkey handling)
--         self.sig_start.connect(self.on_start)
--@@ -249,6 +247,10 @@ class MainWindow(
--         self.chk_octave_range_auto.stateChanged.connect(self._on_octave_range_mode_changed)
--         self.sp_octave_min.valueChanged.connect(self._on_octave_range_changed)
--         self.sp_octave_max.valueChanged.connect(self._on_octave_range_changed)
--+        # Sync editor keyboard config when root/octave/preset changes
--+        self.cmb_root.currentIndexChanged.connect(self._sync_editor_keyboard_config)
--+        self.cmb_octave.currentIndexChanged.connect(self._sync_editor_keyboard_config)
--+        self.cmb_preset.currentIndexChanged.connect(self._sync_editor_keyboard_config)
-- 
--         # buttons
--         btns = QHBoxLayout()
--@@ -344,68 +346,7 @@ class MainWindow(
--         self.btn_floating.setText(tr("show_floating", self.lang))
--         # Diagnostics button
--         self.btn_diagnostics.setText(tr("show_diagnostics", self.lang))
---        # Main settings input style
---        self.lbl_input_style.setText(tr("input_style", self.lang))
---        # Input style tab
---        self.tabs.setTabText(3, tr("tab_input_style", self.lang))
---        self.lbl_current_style.setText(tr("current_style", self.lang) + ":")
---        self.grp_style_params.setTitle(tr("style_params", self.lang))
---        self.lbl_timing_offset.setText(tr("timing_offset", self.lang))
---        self.lbl_timing_min.setText(tr("timing_offset_min", self.lang) + ":")
---        self.lbl_timing_max.setText(tr("timing_offset_max", self.lang) + ":")
---        self.lbl_stagger.setText(tr("chord_stagger", self.lang))
---        self.lbl_duration_var.setText(tr("duration_variation", self.lang))
---        self.grp_custom_style.setTitle(tr("style_custom", self.lang))
---        self.lbl_style_name.setText(tr("style_name", self.lang))
---        self.lbl_style_desc.setText(tr("style_description", self.lang))
---        self.btn_add_style.setText(tr("add_style", self.lang))
---        self.btn_delete_style.setText(tr("delete_style", self.lang))
---        self.btn_apply_style.setText(tr("apply_style", self.lang))
---        # Eight-Bar Style translations
---        self.grp_eight_bar.setTitle(tr("eight_bar_style", self.lang))
---        self.lbl_eight_bar_enabled.setText(tr("eight_bar_enabled", self.lang))
---        self.lbl_eight_bar_mode.setText(tr("eight_bar_mode", self.lang))
---        # Update mode combo translations
---        self.cmb_eight_bar_mode.setItemText(0, tr("mode_warp", self.lang))
---        self.cmb_eight_bar_mode.setItemText(1, tr("mode_beat_lock", self.lang))
---        self.lbl_eight_bar_pattern.setText(tr("eight_bar_pattern", self.lang))
---        self.lbl_eight_bar_clamp.setText(tr("eight_bar_clamp", self.lang))
---        self.lbl_eight_bar_clamp_min.setText(tr("range_min", self.lang))
---        self.lbl_eight_bar_clamp_max.setText(tr("range_max", self.lang))
---        self.lbl_speed_var.setText(tr("speed_variation", self.lang))
---        self.lbl_timing_var.setText(tr("timing_variation", self.lang))
---        self.lbl_dur_var_8bar.setText(tr("duration_variation_8bar", self.lang))
---        self.lbl_eight_bar_preset.setText(tr("eight_bar_preset", self.lang))
---        self.btn_preset_subtle.setText(tr("preset_subtle", self.lang))
---        self.btn_preset_moderate.setText(tr("preset_moderate", self.lang))
---        self.btn_preset_dramatic.setText(tr("preset_dramatic", self.lang))
---        self.lbl_show_indicator.setText(tr("show_indicator", self.lang))
---        # Update pattern combo translations
---        self.cmb_eight_bar_pattern.setItemText(0, tr("pattern_skip3", self.lang))
---        self.cmb_eight_bar_pattern.setItemText(1, tr("pattern_skip2", self.lang))
---        self.cmb_eight_bar_pattern.setItemText(2, tr("pattern_skip1", self.lang))
---        self.cmb_eight_bar_pattern.setItemText(3, tr("pattern_continuous", self.lang))
---        # Rebuild style combos with new language
---        self._rebuild_all_style_combos()
---        # Error Settings tab (Tab 5)
---        self.tabs.setTabText(4, tr("tab_errors", self.lang))
---        self.grp_error_types.setTitle(tr("error_types", self.lang))
---        self.lbl_error_enabled.setText(tr("enable_errors", self.lang))
---        self.lbl_error_freq.setText(tr("errors_per_8bars", self.lang))
---        self.chk_wrong_note.setText(tr("error_wrong_note", self.lang))
---        self.chk_miss_note.setText(tr("error_miss_note", self.lang))
---        self.chk_extra_note.setText(tr("error_extra_note", self.lang))
---        self.chk_pause_error.setText(tr("error_pause", self.lang))
---        self.lbl_pause_range.setText(tr("pause_duration", self.lang))
---        # Quick Error Select in Tab 1
---        self.grp_quick_error.setTitle(tr("quick_error_select", self.lang))
---        self.chk_quick_error_enable.setText(tr("errors", self.lang))
---        self.chk_quick_wrong.setText(tr("error_wrong_note", self.lang))
---        self.chk_quick_miss.setText(tr("error_miss_note", self.lang))
---        self.chk_quick_extra.setText(tr("error_extra_note", self.lang))
---        self.chk_quick_pause.setText(tr("error_pause", self.lang))
---        # Quick 8-Bar toggle in Tab 1
---        self.lbl_quick_eight_bar.setText(tr("eight_bar_enabled", self.lang))
--+        # Main settings input style (removed - now in editor)
--         # Settings Presets group
--         self.grp_presets.setTitle(tr("settings_presets", self.lang))
--         self.lbl_preset_select.setText(tr("preset_select", self.lang))
--@@ -415,17 +356,12 @@ class MainWindow(
--         self.btn_reset_defaults.setText(tr("reset_defaults", self.lang))
--         # Rebuild preset combo for language change
--         self._rebuild_settings_preset_combo()
---        # Range labels (Phase 2 i18n fix)
---        self.lbl_speed_min.setText(tr("range_min", self.lang))
---        self.lbl_speed_max.setText(tr("range_max", self.lang))
---        self.lbl_timing_min.setText(tr("range_min", self.lang))
---        self.lbl_timing_max.setText(tr("range_max", self.lang))
---        self.lbl_dur_min.setText(tr("range_min", self.lang))
---        self.lbl_dur_max.setText(tr("range_max", self.lang))
---        self.lbl_pause_to.setText(tr("range_to", self.lang))
---        # Placeholder texts
---        self.txt_style_name.setPlaceholderText(tr("placeholder_style_name", self.lang))
---        self.txt_style_desc.setPlaceholderText(tr("placeholder_style_desc", self.lang))
--+        # Strict Mode / Auto-Pause group
--+        self.grp_strict_mode.setTitle(tr("strict_mode_group", self.lang))
--+        self.lbl_strict_mode.setText(tr("strict_mode", self.lang))
--+        self.chk_strict_mode.setToolTip(tr("strict_mode_hint", self.lang))
--+        self.lbl_pause_bars.setText(tr("pause_every_bars", self.lang))
--+        self.lbl_auto_resume_countdown.setText(tr("auto_resume_countdown", self.lang))
--         # Sync diagnostics window language if open
--         if self.diagnostics_window:
--             self.diagnostics_window.apply_language(self.lang)
--@@ -453,14 +389,6 @@ class MainWindow(
--         """Rebuild all style combo boxes (after language change or style add/delete)."""
--         current_style = getattr(self, '_current_input_style', 'mechanical')
-- 
---        # Rebuild main settings combo
---        self._rebuild_style_combo(self.cmb_input_style)
---        self._select_style_in_combo(self.cmb_input_style, current_style)
---
---        # Rebuild style tab combo
---        self._rebuild_style_combo(self.cmb_style_tab)
---        self._select_style_in_combo(self.cmb_style_tab, current_style)
---
--         # Rebuild floating controller combo if exists
--         if self.floating_controller:
--             self.floating_controller.rebuild_style_combo(current_style)
--@@ -474,184 +402,6 @@ class MainWindow(
--                 break
--         combo.blockSignals(False)
-- 
---    def _update_style_params_display(self, style_name: str):
---        """Update the style parameters spinboxes to show the selected style."""
---        style = INPUT_STYLES.get(style_name)
---        if not style:
---            return
---        self.sp_timing_min.blockSignals(True)
---        self.sp_timing_max.blockSignals(True)
---        self.sp_stagger.blockSignals(True)
---        self.sp_duration_var.blockSignals(True)
---
---        self.sp_timing_min.setValue(style.timing_offset_ms[0])
---        self.sp_timing_max.setValue(style.timing_offset_ms[1])
---        self.sp_stagger.setValue(style.stagger_ms)
---        self.sp_duration_var.setValue(int(style.duration_variation * 100))
---
---        self.sp_timing_min.blockSignals(False)
---        self.sp_timing_max.blockSignals(False)
---        self.sp_stagger.blockSignals(False)
---        self.sp_duration_var.blockSignals(False)
---
---    def on_input_style_changed(self, index: int):
---        """Called when main settings input style combo changes."""
---        style_name = self.cmb_input_style.itemData(index)
---        if not style_name:
---            return
---        self._current_input_style = style_name
---
---        # Sync style tab combo
---        self._select_style_in_combo(self.cmb_style_tab, style_name)
---        self._update_style_params_display(style_name)
---
---        # Sync floating controller
---        if self.floating_controller:
---            self.floating_controller.sync_style(style_name)
---
---        # Log
---        style = INPUT_STYLES.get(style_name)
---        if style:
---            desc = style.description_zh if self.lang == LANG_ZH else style.description_en
---            self.append_log(f"Input style: {style_name} ({desc})")
---
---        # Auto-save settings
---        self.save_settings()
---
---    def on_style_tab_changed(self, index: int):
---        """Called when style tab combo changes."""
---        style_name = self.cmb_style_tab.itemData(index)
---        if not style_name:
---            return
---        self._current_input_style = style_name
---
---        # Sync main settings combo
---        self._select_style_in_combo(self.cmb_input_style, style_name)
---        self._update_style_params_display(style_name)
---
---        # Sync floating controller
---        if self.floating_controller:
---            self.floating_controller.sync_style(style_name)
---
---        # Log
---        style = INPUT_STYLES.get(style_name)
---        if style:
---            desc = style.description_zh if self.lang == LANG_ZH else style.description_en
---            self.append_log(f"Input style: {style_name} ({desc})")
---
---        # Auto-save settings
---        self.save_settings()
---
---    def on_add_custom_style(self):
---        """Add a new custom style with current parameter values."""
---        name = self.txt_style_name.text().strip()
---        if not name:
---            QMessageBox.warning(self, "Error", "Please enter a style name." if self.lang == LANG_EN else "请输入风格名称。")
---            return
---        if name in INPUT_STYLES:
---            QMessageBox.warning(self, "Error", f"Style '{name}' already exists." if self.lang == LANG_EN else f"风格 '{name}' 已存在。")
---            return
---
---        desc = self.txt_style_desc.text().strip() or name
---        timing_min = self.sp_timing_min.value()
---        timing_max = self.sp_timing_max.value()
---        stagger = self.sp_stagger.value()
---        duration_var = self.sp_duration_var.value() / 100.0
---
---        # Add translation for the new style
---        TRANSLATIONS[f"style_{name}"] = {LANG_EN: name.capitalize(), LANG_ZH: desc}
---
---        # Create and register the new style
---        new_style = InputStyle(
---            name=name,
---            timing_offset_ms=(timing_min, timing_max),
---            stagger_ms=stagger,
---            duration_variation=duration_var,
---            description_en=desc,
---            description_zh=desc,
---            builtin=False,  # User-created styles are not builtin
---        )
---        register_style(new_style)
---
---        # Rebuild all combos and select the new style
---        self._current_input_style = name
---        self._rebuild_all_style_combos()
---        self._select_style_in_combo(self.cmb_input_style, name)
---        self._select_style_in_combo(self.cmb_style_tab, name)
---
---        self.append_log(f"Added custom style: {name}")
---        self.txt_style_name.clear()
---        self.txt_style_desc.clear()
---        self.save_settings()  # Auto-save custom styles
---
---    def on_delete_custom_style(self):
---        """Delete the currently selected custom style (cannot delete built-in styles)."""
---        style_name = self.cmb_style_tab.currentData()
---        if not style_name:
---            return
---
---        # Check if style is built-in (via registry)
---        style = get_style(style_name)
---        if style and getattr(style, 'builtin', False):
---            QMessageBox.warning(self, "Error",
---                "Cannot delete built-in styles." if self.lang == LANG_EN else "无法删除内置风格。")
---            return
---
---        # Confirm deletion
---        result = QMessageBox.question(self, "Confirm",
---            f"Delete style '{style_name}'?" if self.lang == LANG_EN else f"删除风格 '{style_name}'?",
---            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
---        if result != QMessageBox.StandardButton.Yes:
---            return
---
---        # Delete the style using registry
---        unregister_style(style_name)
---        if f"style_{style_name}" in TRANSLATIONS:
---            del TRANSLATIONS[f"style_{style_name}"]
---
---        # Reset to mechanical and rebuild
---        self._current_input_style = "mechanical"
---        self._rebuild_all_style_combos()
---        self._update_style_params_display("mechanical")
---
---        self.append_log(f"Deleted custom style: {style_name}")
---        self.save_settings()  # Auto-save custom styles
---
---    def on_apply_style_params(self):
---        """Apply the current parameter values to the selected style."""
---        style_name = self.cmb_style_tab.currentData()
---        if not style_name:
---            return
---
---        # Check if style is built-in (via registry)
---        style = get_style(style_name)
---        if style and getattr(style, 'builtin', False):
---            QMessageBox.information(self, "Info",
---                "Cannot modify built-in styles. Use 'Add Style' to create a custom copy." if self.lang == LANG_EN
---                else "无法修改内置风格。请使用'添加风格'创建自定义副本。")
---            return
---
---        # Update the custom style
---        if style:
---            timing_min = self.sp_timing_min.value()
---            timing_max = self.sp_timing_max.value()
---            stagger = self.sp_stagger.value()
---            duration_var = self.sp_duration_var.value() / 100.0
---
---            # Create a new style with updated values (dataclass is immutable by default)
---            updated_style = InputStyle(
---                name=style_name,
---                timing_offset_ms=(timing_min, timing_max),
---                stagger_ms=stagger,
---                duration_variation=duration_var,
---                description_en=style.description_en,
---                description_zh=style.description_zh,
---                builtin=False,  # Modified styles are not builtin
---            )
---            INPUT_STYLES[style_name] = updated_style
---            self.append_log(f"Updated style: {style_name} (offset={timing_min}~{timing_max}ms, stagger={stagger}ms, var={duration_var*100:.0f}%)")
---            self.save_settings()  # Auto-save custom styles
---
--     # ---- Settings Preset Methods ----
-- 
--     def on_import_settings(self):
--@@ -874,6 +624,12 @@ class MainWindow(
--             self.editor_window.bpm_changed.connect(self._on_editor_bpm_changed)
-- 
--         self.editor_window.load_midi(path)
--+        # Sync keyboard config (effective root = root + octave_shift * 12)
--+        root_note = self.cmb_root.currentData() or 60  # Default C4
--+        octave_shift = self.cmb_octave.currentData() or 0
--+        effective_root = root_note + (octave_shift * 12)
--+        preset = self.cmb_preset.currentData() or "21-key"
--+        self.editor_window.set_keyboard_config(effective_root, preset)
--         self.editor_window.show()
--         self.editor_window.raise_()
--         self.editor_window.activateWindow()
--@@ -905,6 +661,16 @@ class MainWindow(
--         if self.floating_controller and self.floating_controller.isVisible():
--             self.floating_controller._sync_from_main()
-- 
--+    def _sync_editor_keyboard_config(self):
--+        """Sync keyboard config to editor when root/octave/preset changes in main window."""
--+        if self.editor_window is None or not self.editor_window.isVisible():
--+            return
--+        root_note = self.cmb_root.currentData() or 60
--+        octave_shift = self.cmb_octave.currentData() or 0
--+        effective_root = root_note + (octave_shift * 12)
--+        preset = self.cmb_preset.currentData() or "21-key"
--+        self.editor_window.set_keyboard_config(effective_root, preset)
--+
--     def on_browse_sf(self):
--         settings = QSettings("LyreAutoPlayer", "LyreAutoPlayer")
--         last_dir = settings.value(SETTINGS_SF_DIR, "")
--@@ -926,112 +692,21 @@ class MainWindow(
--             self.floating_controller.sync_error_settings(self._error_enabled, self._error_freq)
--         self.append_log(f"Error simulation: {'ON' if self._error_enabled else 'OFF'}")
-- 
---    def _on_error_freq_changed(self, value: int):
---        """Change error frequency (per 8 bars)."""
---        self._error_freq = value
---        if self.floating_controller:
---            self.floating_controller.sync_error_settings(self._error_enabled, self._error_freq)
--+    # ---- Strict Mode Methods ----
-- 
---    def _on_quick_error_enable_changed(self, state: int):
---        """Sync quick error enable checkbox from Tab 1 to Tab 5."""
---        enabled = state == Qt.CheckState.Checked.value
---        self._error_enabled = enabled
---        # Sync to Tab 5
---        self.chk_error_enabled.setChecked(enabled)
---        # Sync to FloatingController
---        if self.floating_controller:
---            self.floating_controller.sync_error_settings(self._error_enabled, self._error_freq)
---        self.append_log(f"Error simulation: {'ON' if enabled else 'OFF'}")
---
---    def _sync_quick_errors_to_tab5(self, state: int = None):
---        """Sync error type checkboxes from Tab 1 to Tab 5 (with signal blocking)."""
---        # Block Tab 5 signals to prevent infinite recursion
---        self.chk_wrong_note.blockSignals(True)
---        self.chk_miss_note.blockSignals(True)
---        self.chk_extra_note.blockSignals(True)
---        self.chk_pause_error.blockSignals(True)
---
---        self.chk_wrong_note.setChecked(self.chk_quick_wrong.isChecked())
---        self.chk_miss_note.setChecked(self.chk_quick_miss.isChecked())
---        self.chk_extra_note.setChecked(self.chk_quick_extra.isChecked())
---        self.chk_pause_error.setChecked(self.chk_quick_pause.isChecked())
---
---        self.chk_wrong_note.blockSignals(False)
---        self.chk_miss_note.blockSignals(False)
---        self.chk_extra_note.blockSignals(False)
---        self.chk_pause_error.blockSignals(False)
---
---    def _sync_tab5_errors_to_quick(self):
---        """Sync error settings from Tab 5 to Tab 1 quick checkboxes."""
---        self.chk_quick_error_enable.setChecked(self.chk_error_enabled.isChecked())
---        self.chk_quick_wrong.setChecked(self.chk_wrong_note.isChecked())
---        self.chk_quick_miss.setChecked(self.chk_miss_note.isChecked())
---        self.chk_quick_extra.setChecked(self.chk_extra_note.isChecked())
---        self.chk_quick_pause.setChecked(self.chk_pause_error.isChecked())
---
---    def _sync_tab5_to_quick_errors(self, state: int = None):
---        """Sync from Tab 5 to Tab 1 (with signal blocking to prevent recursion)."""
---        # Block Tab 1 signals to prevent infinite recursion
---        self.chk_quick_wrong.blockSignals(True)
---        self.chk_quick_miss.blockSignals(True)
---        self.chk_quick_extra.blockSignals(True)
---        self.chk_quick_pause.blockSignals(True)
---
---        self.chk_quick_wrong.setChecked(self.chk_wrong_note.isChecked())
---        self.chk_quick_miss.setChecked(self.chk_miss_note.isChecked())
---        self.chk_quick_extra.setChecked(self.chk_extra_note.isChecked())
---        self.chk_quick_pause.setChecked(self.chk_pause_error.isChecked())
---
---        self.chk_quick_wrong.blockSignals(False)
---        self.chk_quick_miss.blockSignals(False)
---        self.chk_quick_extra.blockSignals(False)
---        self.chk_quick_pause.blockSignals(False)
---
---    # ---- Eight-Bar Style Methods ----
---
---    def _on_eight_bar_enabled_changed(self, state: int):
---        """Toggle eight-bar style variation on/off."""
--+    def _on_strict_mode_changed(self, state: int):
--+        """Toggle strict mode on/off. When ON, disables various playback variation controls."""
--         enabled = state == Qt.CheckState.Checked.value
---        self.append_log(f"8-Bar variation: {'ON' if enabled else 'OFF'}")
---        # Sync to quick checkbox in Tab 1
---        self.chk_quick_eight_bar.blockSignals(True)
---        self.chk_quick_eight_bar.setChecked(enabled)
---        self.chk_quick_eight_bar.blockSignals(False)
---        # Sync to floating controller if exists
---        if self.floating_controller:
---            self.floating_controller.sync_eight_bar_enabled(enabled)
--+        self._strict_mode = enabled
-- 
---    def _apply_eight_bar_preset(self, preset_name: str):
---        """Apply a predefined eight-bar style preset."""
---        if preset_name not in EIGHT_BAR_PRESETS:
---            return
---        preset = EIGHT_BAR_PRESETS[preset_name]
--+        # Disable controls that strict mode overrides (only remaining widgets)
--+        self.sp_speed.setEnabled(not enabled)
--+        self.chk_midi_duration.setEnabled(not enabled)
-- 
---        # Apply values to UI
---        self.sp_speed_min.setValue(int(preset.speed_mult_min * 100))
---        self.sp_speed_max.setValue(int(preset.speed_mult_max * 100))
---        self.sp_timing_var_min.setValue(int(preset.timing_mult_min * 100))
---        self.sp_timing_var_max.setValue(int(preset.timing_mult_max * 100))
---        self.sp_dur_var_min.setValue(int(preset.duration_mult_min * 100))
---        self.sp_dur_var_max.setValue(int(preset.duration_mult_max * 100))
---
---        self.append_log(f"8-Bar preset applied: {preset_name}")
---
---    def _on_quick_eight_bar_changed(self, state: int):
---        """Sync quick 8-bar toggle from Tab 1 to Tab 4 (Input Style)."""
---        enabled = state == Qt.CheckState.Checked.value
---        # Sync to Tab 4 checkbox (block signals to prevent recursion)
---        self.chk_eight_bar_enabled.blockSignals(True)
---        self.chk_eight_bar_enabled.setChecked(enabled)
---        self.chk_eight_bar_enabled.blockSignals(False)
---        # Trigger the main handler
---        self._on_eight_bar_enabled_changed(state)
---
---    def _sync_eight_bar_to_quick(self):
---        """Sync 8-bar enabled state from Tab 4 to Tab 1 quick checkbox."""
---        self.chk_quick_eight_bar.blockSignals(True)
---        self.chk_quick_eight_bar.setChecked(self.chk_eight_bar_enabled.isChecked())
---        self.chk_quick_eight_bar.blockSignals(False)
--+        # Log state change
--+        self.append_log(f"Strict mode: {'ON' if enabled else 'OFF'}")
--+        if enabled:
--+            self.append_log("  → Speed=1.0, Duration=ON")
-- 
--     def closeEvent(self, event):
--         """Cleanup global hotkeys on window close."""
--diff --git a/LyreAutoPlayer/player/config.py b/LyreAutoPlayer/player/config.py
--index 36517e4..094f00f 100644
----- a/LyreAutoPlayer/player/config.py
--+++ b/LyreAutoPlayer/player/config.py
--@@ -45,3 +45,10 @@ class PlayerConfig:
-- 
--     # Diagnostics (for debugging input issues)
--     enable_diagnostics: bool = False
--+
--+    # Unified playback engine (统一播放引擎)
--+    strict_mode: bool = True              # 严格跟谱模式 (默认开启)
--+    pause_every_bars: int = 0             # 自动暂停间隔 (0=禁用, 1/2/4/8)
--+    auto_resume_countdown: int = 3        # 倒计时秒数
--+    bar_duration_override: float = 0.0    # 覆盖小节时长 (秒), 0=自动计算
--+    editor_bpm: int = 0                   # 编辑器 BPM, 0=使用 MIDI 原始值
--diff --git a/LyreAutoPlayer/player/thread.py b/LyreAutoPlayer/player/thread.py
--index 36a7606..3f74523 100644
----- a/LyreAutoPlayer/player/thread.py
--+++ b/LyreAutoPlayer/player/thread.py
--@@ -85,6 +85,9 @@ class PlayerThread(QThread):
--     finished = pyqtSignal()
--     progress = pyqtSignal(float, float)  # (current_time, total_duration)
--     paused = pyqtSignal()  # Emitted when actually paused (for UI update)
--+    resumed = pyqtSignal()  # Emitted when playback resumes (for UI update)
--+    countdown_tick = pyqtSignal(int)  # remaining seconds (0=countdown finished)
--+    auto_pause_at_bar = pyqtSignal(int)  # bar_index where auto-paused
-- 
--     def __init__(self, events: List[NoteEvent], cfg: PlayerConfig):
--         super().__init__()
--@@ -155,11 +158,13 @@ class PlayerThread(QThread):
--             # Cancel pending pause
--             self._pause_pending = False
--             self.log.emit("Pause cancelled")
--+            self.resumed.emit()  # Notify UI
--         elif self._paused:
--             pause_duration = time.perf_counter() - self._pause_start
--             self._total_pause_time += pause_duration
--             self._paused = False
--             self.log.emit(f"Resumed (paused {pause_duration:.1f}s)")
--+            self.resumed.emit()  # Notify UI
-- 
--     def is_paused(self) -> bool:
--         return self._paused
--@@ -223,11 +228,14 @@ class PlayerThread(QThread):
--             self.log.emit(f"Countdown: {self.cfg.countdown_sec}s (switch to game now)")
--             for i in range(self.cfg.countdown_sec, 0, -1):
--                 if self._stop:
--+                    self.countdown_tick.emit(0)  # Clear countdown UI
--                     self.log.emit("Stopped during countdown.")
--                     self.finished.emit()
--                     return
--+                self.countdown_tick.emit(i)  # Notify UI of countdown
--                 self.log.emit(f"  ...{i}")
--                 time.sleep(1)
--+            self.countdown_tick.emit(0)  # Countdown finished
-- 
--         # Disable IME for target window
--         ime_disabled_hwnd = None
--@@ -382,6 +390,11 @@ class PlayerThread(QThread):
--             except Exception:
--                 pass
-- 
--+        # Override bar duration from editor BPM (Pitfall #2: must be before event queue build)
--+        if self.cfg.bar_duration_override > 0:
--+            self._bar_duration = self.cfg.bar_duration_override
--+            self.log.emit(f"Using editor bar duration: {self._bar_duration:.3f}s")
--+
--         # 8-bar style setup
--         eight_bar = self.cfg.eight_bar_style
--         eight_bar_segments, segment_duration, beat_duration, warp_start = self._setup_eight_bar(eight_bar, speed)
--@@ -790,6 +803,10 @@ class PlayerThread(QThread):
--                     break
--                 time.sleep(min(dt, 0.02))
--                 now = time.perf_counter() - start - self._total_pause_time
--+                # Emit progress at ~10Hz for smooth playhead updates
--+                if now - self._last_progress_emit >= 0.1:
--+                    self.progress.emit(now, self._total_duration)
--+                    self._last_progress_emit = now
--                 dt = target_time - now
-- 
--             if self._paused:
--@@ -811,13 +828,40 @@ class PlayerThread(QThread):
--                 processed_bar = next_event.bar_index
-- 
--                 if next_event.event_type == "pause_marker":
---                    if self._pause_pending:
--+                    # Check if auto-pause should trigger at this bar
--+                    should_auto_pause = (
--+                        self.cfg.pause_every_bars > 0 and
--+                        next_event.bar_index > 0 and
--+                        next_event.bar_index % self.cfg.pause_every_bars == 0
--+                    )
--+
--+                    if self._pause_pending or should_auto_pause:
--                         self.log.emit(
---                            f"[Pause] pending at bar {next_event.bar_index} (t={next_event.time:.3f}s)"
--+                            f"[Pause] {'auto-' if should_auto_pause else 'pending '}at bar {next_event.bar_index} (t={next_event.time:.3f}s)"
--                         )
---                        self._do_pause()
--                         self._release_all_pressed(pressed_keys, fs, chan)
--+                        self._do_pause()
--+                        self.auto_pause_at_bar.emit(next_event.bar_index)
--                         paused_now = True
--+
--+                        if should_auto_pause:
--+                            # Auto-pause countdown (倒计时结束自动继续，F5可提前跳过)
--+                            countdown_interrupted = False
--+                            for remaining in range(self.cfg.auto_resume_countdown, 0, -1):
--+                                if self._stop:
--+                                    break
--+                                if not self._paused:  # User pressed F5 to skip
--+                                    self.countdown_tick.emit(0)  # Clear countdown UI
--+                                    countdown_interrupted = True
--+                                    break
--+                                self.countdown_tick.emit(remaining)
--+                                time.sleep(1.0)
--+
--+                            # Auto-resume after countdown (if still paused and not interrupted)
--+                            if self._paused and not self._stop and not countdown_interrupted:
--+                                self.countdown_tick.emit(0)
--+                                self.resume()  # 自动继续
--+
--                         break
--                     continue
-- 
--diff --git a/LyreAutoPlayer/settings.json b/LyreAutoPlayer/settings.json
--index 0855327..47e3aa5 100644
----- a/LyreAutoPlayer/settings.json
--+++ b/LyreAutoPlayer/settings.json
--@@ -19,32 +19,37 @@
--   "input_style": "mechanical",
--   "enable_diagnostics": false,
--   "soundfont_path": "C:\\soundfonts\\FluidR3_GM.sf2",
---  "last_midi_path": "d:\\dw11\\piano\\lyreautoplayer\\midi-change\\level!_custom.mid",
--+  "last_midi_path": "D:/dw11/piano/LyreAutoPlayer/midi/Canon-In-C-卡农-原神风物之诗琴谱-原琴谱.mid",
--   "input_manager": {},
--   "error_config": {
--     "enabled": false,
--     "errors_per_8bars": 1,
---    "wrong_note": true,
---    "miss_note": true,
---    "extra_note": true,
---    "pause_error": true,
---    "pause_min_ms": 200,
--+    "wrong_note": false,
--+    "miss_note": false,
--+    "extra_note": false,
--+    "pause_error": false,
--+    "pause_min_ms": 100,
--     "pause_max_ms": 500
--   },
--   "eight_bar_config": {
--     "enabled": false,
---    "mode": "beat_lock",
---    "pattern": "continuous",
---    "speed_min": 85,
---    "speed_max": 103,
---    "timing_min": 85,
---    "timing_max": 103,
---    "duration_min": 85,
---    "duration_max": 103,
---    "clamp_enabled": true,
--+    "mode": "warp",
--+    "pattern": "skip2_pick1",
--+    "speed_min": 95,
--+    "speed_max": 105,
--+    "timing_min": 95,
--+    "timing_max": 105,
--+    "duration_min": 95,
--+    "duration_max": 105,
--+    "clamp_enabled": false,
--     "clamp_min": 85,
--     "clamp_max": 115,
---    "show_indicator": true
--+    "show_indicator": false
--+  },
--+  "strict_mode_config": {
--+    "enabled": true,
--+    "pause_every_bars": 0,
--+    "auto_resume_countdown": 3
--   },
--   "custom_styles": [
--     {
--diff --git a/LyreAutoPlayer/ui/editor/__init__.py b/LyreAutoPlayer/ui/editor/__init__.py
--index 123a6c6..2a8a04e 100644
----- a/LyreAutoPlayer/ui/editor/__init__.py
--+++ b/LyreAutoPlayer/ui/editor/__init__.py
--@@ -6,6 +6,8 @@ from .piano_roll import PianoRollWidget
-- from .note_item import NoteItem
-- from .timeline import TimelineWidget
-- from .keyboard import KeyboardWidget
--+from .countdown_overlay import CountdownOverlay
--+from .key_list_widget import KeyListWidget
-- 
-- __all__ = [
--     "EditorWindow",
--@@ -13,4 +15,6 @@ __all__ = [
--     "NoteItem",
--     "TimelineWidget",
--     "KeyboardWidget",
--+    "CountdownOverlay",
--+    "KeyListWidget",
-- ]
--diff --git a/LyreAutoPlayer/ui/editor/editor_window.py b/LyreAutoPlayer/ui/editor/editor_window.py
--index 3f6030b..396f71a 100644
----- a/LyreAutoPlayer/ui/editor/editor_window.py
--+++ b/LyreAutoPlayer/ui/editor/editor_window.py
--@@ -9,6 +9,7 @@ Features:
-- import os
-- import sys
-- import json
--+import random
-- from pathlib import Path
-- from typing import Optional, Dict
-- from datetime import datetime
--@@ -32,7 +33,11 @@ except ImportError:
-- from .piano_roll import PianoRollWidget
-- from .timeline import TimelineWidget
-- from .keyboard import KeyboardWidget
--+from .countdown_overlay import CountdownOverlay
--+from .key_list_widget import KeyListWidget
--+from .undo_commands import ApplyJitterCommand
-- from i18n import tr, LANG_ZH
--+from style_manager import get_style_names, INPUT_STYLES
-- 
-- 
-- class EditorWindow(QMainWindow):
--@@ -69,6 +74,14 @@ class EditorWindow(QMainWindow):
--         self._chan = 0   # MIDI channel
--         self._active_notes: Dict[int, int] = {}  # 音符 -> 发声计数
-- 
--+        # Unified playback: follow mode state
--+        self._follow_mode = False  # Following PlayerThread (not local timer)
--+        self._main_window = None   # Reference to main window
--+        self._audio_was_enabled = True  # Remember audio state before follow mode
--+
--+        # Octave shift: track previous value for delta calculation
--+        self._prev_octave_shift = 0
--+
--         self._setup_ui()
--         self._setup_toolbar()
--         self._setup_menus()
--@@ -105,17 +118,38 @@ class EditorWindow(QMainWindow):
-- 
--         main_layout.addLayout(timeline_row)
-- 
---        # 键盘 + 卷帘
---        content_row = QHBoxLayout()
---        content_row.setSpacing(0)
--+        # 纵向 Splitter: 上=键盘+卷帘，下=按键进度窗
--+        self.main_splitter = QSplitter(Qt.Orientation.Vertical)
--+        self.main_splitter.setStyleSheet("QSplitter::handle { background-color: #444; height: 4px; }")
--+
--+        # 上部: 键盘 + 卷帘
--+        top_widget = QWidget()
--+        top_layout = QHBoxLayout(top_widget)
--+        top_layout.setContentsMargins(0, 0, 0, 0)
--+        top_layout.setSpacing(0)
-- 
--         self.keyboard = KeyboardWidget()
---        content_row.addWidget(self.keyboard)
--+        top_layout.addWidget(self.keyboard)
-- 
--         self.piano_roll = PianoRollWidget()
---        content_row.addWidget(self.piano_roll)
--+        top_layout.addWidget(self.piano_roll)
--+
--+        self.main_splitter.addWidget(top_widget)
--+
--+        # 下部: 按键进度窗
--+        self.key_list = KeyListWidget()
--+        self.main_splitter.addWidget(self.key_list)
-- 
---        main_layout.addLayout(content_row)
--+        # 设置 splitter 比例 (默认按键进度窗隐藏)
--+        self.main_splitter.setSizes([500, 0])
--+        self.main_splitter.setCollapsible(0, False)  # 上部不可折叠
--+        self.main_splitter.setCollapsible(1, True)   # 下部可折叠
--+
--+        main_layout.addWidget(self.main_splitter)
--+
--+        # Countdown overlay (displayed during auto-pause countdown)
--+        self._countdown_overlay = CountdownOverlay(self.piano_roll)
--+        self._countdown_overlay.setGeometry(self.piano_roll.rect())
-- 
--         # 播放计时器
--         self.playback_timer = QTimer()
--@@ -210,6 +244,52 @@ class EditorWindow(QMainWindow):
-- 
--         toolbar.addSeparator()
-- 
--+        # Auto-pause interval (每 N 小节暂停)
--+        toolbar.addWidget(QLabel(" Pause: "))
--+        self.cmb_pause_bars = QComboBox()
--+        self.cmb_pause_bars.addItem("Off", 0)
--+        self.cmb_pause_bars.addItem("1 bar", 1)
--+        self.cmb_pause_bars.addItem("2 bars", 2)
--+        self.cmb_pause_bars.addItem("4 bars", 4)
--+        self.cmb_pause_bars.addItem("8 bars", 8)
--+        self.cmb_pause_bars.setCurrentIndex(0)
--+        self.cmb_pause_bars.setFixedWidth(70)
--+        self.cmb_pause_bars.setToolTip("Auto-pause every N bars for practice")
--+        toolbar.addWidget(self.cmb_pause_bars)
--+
--+        # Auto-resume countdown
--+        toolbar.addWidget(QLabel(" Resume: "))
--+        self.sp_auto_resume = QSpinBox()
--+        self.sp_auto_resume.setRange(1, 10)
--+        self.sp_auto_resume.setValue(3)
--+        self.sp_auto_resume.setSuffix("s")
--+        self.sp_auto_resume.setFixedWidth(50)
--+        self.sp_auto_resume.setToolTip("Countdown seconds before auto-resume")
--+        toolbar.addWidget(self.sp_auto_resume)
--+
--+        toolbar.addSeparator()
--+
--+        # Overall octave shift (-2 to +2)
--+        toolbar.addWidget(QLabel(" Octave: "))
--+        self.sp_octave_shift = QSpinBox()
--+        self.sp_octave_shift.setRange(-2, 2)
--+        self.sp_octave_shift.setValue(0)
--+        self.sp_octave_shift.setFixedWidth(50)
--+        self.sp_octave_shift.setToolTip("Transpose all notes by octaves (±12 semitones)")
--+        toolbar.addWidget(self.sp_octave_shift)
--+
--+        toolbar.addSeparator()
--+
--+        # Input style for playback (输入风格)
--+        toolbar.addWidget(QLabel(" Input: "))
--+        self.cmb_input_style = QComboBox()
--+        self._populate_input_styles()
--+        self.cmb_input_style.setFixedWidth(100)
--+        self.cmb_input_style.setToolTip("Input style affects timing variations during playback")
--+        toolbar.addWidget(self.cmb_input_style)
--+
--+        toolbar.addSeparator()
--+
--         # 编辑风格选择
--         toolbar.addWidget(QLabel(" Style: "))
--         self.cmb_edit_style = QComboBox()
--@@ -218,6 +298,14 @@ class EditorWindow(QMainWindow):
--         self.cmb_edit_style.setFixedWidth(100)
--         toolbar.addWidget(self.cmb_edit_style)
-- 
--+        toolbar.addSeparator()
--+
--+        # 按键列表开关
--+        self.chk_key_list = QCheckBox("Key List")
--+        self.chk_key_list.setToolTip("Show/hide the key sequence list")
--+        self.chk_key_list.setChecked(False)
--+        toolbar.addWidget(self.chk_key_list)
--+
--     def _setup_menus(self):
--         """设置菜单栏"""
--         menubar = self.menuBar()
--@@ -238,6 +326,14 @@ class EditorWindow(QMainWindow):
-- 
--         edit_menu.addSeparator()
-- 
--+        # Apply input style (humanization)
--+        act_apply_style = edit_menu.addAction(tr("apply_jitter"))
--+        act_apply_style.setShortcut("H")
--+        act_apply_style.setToolTip(tr("apply_jitter_tooltip"))
--+        act_apply_style.triggered.connect(self._apply_input_style_jitter)
--+
--+        edit_menu.addSeparator()
--+
--         # 帮助提示
--         act_create_hint = edit_menu.addAction("Note Creation: Alt+Click/Drag")
--         act_create_hint.setEnabled(False)  # 仅作为提示，不可点击
--@@ -347,6 +443,7 @@ class EditorWindow(QMainWindow):
--         self.cmb_quantize.currentTextChanged.connect(self._on_quantize_changed)
--         self.sp_bpm.valueChanged.connect(self._on_bpm_changed)
--         self.timeline.sig_bpm_changed.connect(self._on_timeline_bpm_changed)
--+        self.sp_octave_shift.valueChanged.connect(self._on_octave_shift_changed)
-- 
--         # 同步滚动
--         self.piano_roll.horizontalScrollBar().valueChanged.connect(
--@@ -355,8 +452,16 @@ class EditorWindow(QMainWindow):
--         self.piano_roll.verticalScrollBar().valueChanged.connect(
--             lambda v: self.keyboard.set_scroll_offset(v)
--         )
--+        # 按键进度窗水平滚动同步
--+        self.piano_roll.horizontalScrollBar().valueChanged.connect(
--+            lambda v: self.key_list.set_scroll_offset(v)
--+        )
--+        # 双向同步：按键进度窗滚动也同步到 PianoRoll
--+        self.key_list.sig_scroll_changed.connect(
--+            lambda v: self._sync_scroll_from_key_list(v)
--+        )
-- 
---        # 同步缩放 (Ctrl+滚轮 → 时间轴 + 滑条)
--+        # 同步缩放 (Ctrl+滚轮 → 时间轴 + 滑条 + 按键进度窗)
--         self.piano_roll.sig_zoom_changed.connect(self._on_piano_roll_zoom)
-- 
--         # 同步行高变化 (Ctrl+Up/Down / [ ] → 键盘)
--@@ -365,6 +470,39 @@ class EditorWindow(QMainWindow):
--         # 键盘拖拽选择音域 → 钢琴卷帘批量选择
--         self.keyboard.sig_range_selected.connect(self.piano_roll.select_by_pitch_range)
-- 
--+        # 按键列表开关
--+        self.chk_key_list.toggled.connect(self._on_key_list_toggled)
--+
--+    def _on_key_list_toggled(self, checked: bool):
--+        """切换按键进度窗显示"""
--+        if checked:
--+            # 显示按键进度窗 (设置合适的高度)
--+            sizes = self.main_splitter.sizes()
--+            total = sum(sizes)
--+            # 底部按键窗占 30% 高度
--+            key_list_height = min(200, total // 3)
--+            self.main_splitter.setSizes([total - key_list_height, key_list_height])
--+            # 更新按键列表内容
--+            events = self.export_events()
--+            self.key_list.set_events(events)
--+            # 同步缩放
--+            self.key_list.set_scale(self.piano_roll.pixels_per_second)
--+        else:
--+            # 隐藏按键进度窗
--+            sizes = self.main_splitter.sizes()
--+            total = sum(sizes)
--+            self.main_splitter.setSizes([total, 0])
--+
--+    def set_keyboard_config(self, root_note: int, layout_name: str):
--+        """设置键盘配置 (同步到 KeyListWidget)
--+
--+        Args:
--+            root_note: 根音 MIDI 编号 (如 60 = C4)
--+            layout_name: 布局名称 (如 "21-key" 或 "36-key")
--+        """
--+        self.key_list.set_root_note(root_note)
--+        self.key_list.set_layout(layout_name)
--+
--     def load_midi(self, path: str, source_path: Optional[str] = None):
--         """加载 MIDI 文件
-- 
--@@ -418,6 +556,12 @@ class EditorWindow(QMainWindow):
--             self.sp_bpm.setValue(midi_bpm)
--             self.sp_bpm.blockSignals(False)
-- 
--+            # 重置八度平移
--+            self._prev_octave_shift = 0
--+            self.sp_octave_shift.blockSignals(True)
--+            self.sp_octave_shift.setValue(0)
--+            self.sp_octave_shift.blockSignals(False)
--+
--             # 同步时间轴为单一 BPM，确保与钢琴卷帘小节线对齐
--             self._sync_timeline_tempo(midi_bpm)
-- 
--@@ -443,6 +587,9 @@ class EditorWindow(QMainWindow):
--                 })
--             self.midi_loaded.emit(path, events_list)
-- 
--+            # 更新按键列表
--+            self.key_list.set_events(events_list)
--+
--         except Exception as e:
--             QMessageBox.critical(self, "Error", f"Failed to load MIDI:\n{e}")
-- 
--@@ -644,6 +791,125 @@ class EditorWindow(QMainWindow):
--         # Notify main window of BPM change
--         self.bpm_changed.emit(bpm)
-- 
--+    def _on_octave_shift_changed(self, value: int):
--+        """八度平移变化 - 实际修改音符数据
--+
--+        When octave shift changes, actually transpose all notes by the delta.
--+        This modifies the underlying MIDI data, not just playback mapping.
--+        """
--+        delta = value - self._prev_octave_shift
--+        if delta == 0:
--+            return
--+
--+        # Calculate semitone shift (octave = 12 semitones)
--+        semitone_shift = delta * 12
--+
--+        # Transpose all notes
--+        for note_item in self.piano_roll.notes:
--+            note_item.note = max(0, min(127, note_item.note + semitone_shift))
--+
--+        # Update previous value
--+        self._prev_octave_shift = value
--+
--+        # Refresh display
--+        self.piano_roll._refresh_notes()
--+
--+        # Update key list if visible
--+        if self.chk_key_list.isChecked():
--+            events = self.export_events()
--+            self.key_list.set_events(events)
--+
--+        # Log the change
--+        self.statusBar().showMessage(
--+            f"Transposed all notes by {delta:+d} octave(s) ({semitone_shift:+d} semitones)", 3000
--+        )
--+
--+    def _apply_input_style_jitter(self):
--+        """Apply input style timing jitter to notes (humanization).
--+
--+        Gets the selected input style and applies random timing offset
--+        to selected notes (or all notes if none selected).
--+        Also applies duration variation based on the style.
--+        Uses QUndoCommand for proper undo/redo support.
--+        """
--+        # Get selected input style
--+        style_name = self.cmb_input_style.currentText()
--+        style = INPUT_STYLES.get(style_name)
--+
--+        if style is None:
--+            QMessageBox.warning(
--+                self, tr("input_style"),
--+                tr("style_not_found_msg").format(name=style_name)
--+            )
--+            return
--+
--+        # Check if style has any variation
--+        min_offset, max_offset = style.timing_offset_ms
--+        duration_var = style.duration_variation
--+
--+        if min_offset == 0 and max_offset == 0 and duration_var == 0.0:
--+            QMessageBox.information(
--+                self, tr("input_style"),
--+                tr("style_no_variation").format(name=style_name)
--+            )
--+            return
--+
--+        # Get target notes (selected or all)
--+        selected = [item for item in self.piano_roll.notes if item.isSelected()]
--+        if selected:
--+            target_notes = selected
--+        else:
--+            target_notes = list(self.piano_roll.notes)
--+
--+        if not target_notes:
--+            QMessageBox.information(
--+                self, tr("input_style"),
--+                tr("no_notes_to_jitter")
--+            )
--+            return
--+
--+        # Prepare note data for undo command
--+        notes_data = []
--+        for item in target_notes:
--+            notes_data.append({
--+                "note": item.note,
--+                "start": item.start_time,
--+                "duration": item.duration,
--+                "velocity": item.velocity
--+            })
--+
--+        # Create and execute undo command
--+        cmd = ApplyJitterCommand(
--+            self.piano_roll,
--+            notes_data,
--+            timing_offset_ms=style.timing_offset_ms,
--+            duration_variation=duration_var,
--+            style_name=style_name
--+        )
--+        self.piano_roll.undo_stack.push(cmd)
--+
--+        # Update key list if visible
--+        if self.chk_key_list.isChecked():
--+            events = self.export_events()
--+            self.key_list.set_events(events)
--+
--+        # Emit notes changed for tracking
--+        self.piano_roll.sig_notes_changed.emit()
--+
--+        # Log the change
--+        scope = tr("scope_selected") if selected else tr("scope_all")
--+        self.statusBar().showMessage(
--+            tr("jitter_applied").format(
--+                style=style_name,
--+                count=len(target_notes),
--+                scope=scope,
--+                min_offset=min_offset,
--+                max_offset=max_offset,
--+                duration_pct=abs(duration_var) * 100
--+            ),
--+            5000
--+        )
--+
--     def _update_bar_lines(self):
--         """更新钢琴卷帘的小节分隔线"""
--         bpm = max(1, int(self.sp_bpm.value()))
--@@ -1088,6 +1354,12 @@ class EditorWindow(QMainWindow):
--         如果 Audio checkbox 被勾选，会尝试初始化音频引擎并播放声音。
--         如果未勾选或音频初始化失败，仍然可以进行视觉预览（播放头移动）。
--         """
--+        # In follow mode, delegate to main window (F5 toggle)
--+        if self._follow_mode:
--+            if self._main_window:
--+                self._main_window.on_toggle_play_pause()
--+            return
--+
--         if self.is_playing:
--             self.is_playing = False
--             self.playback_timer.stop()
--@@ -1135,6 +1407,8 @@ class EditorWindow(QMainWindow):
--         self.timeline.set_playhead(0.0)
--         self.act_play.setText("Play")
--         self._update_time_label()
--+        # 重置按键列表
--+        self.key_list.reset()
-- 
--     def on_seek(self, time_sec: float):
--         """跳转到指定时间"""
--@@ -1142,6 +1416,9 @@ class EditorWindow(QMainWindow):
--         self.piano_roll.set_playhead_position(time_sec)
--         self.timeline.set_playhead(time_sec)
--         self._update_time_label()
--+        # 更新按键列表进度
--+        if self.chk_key_list.isChecked():
--+            self.key_list.update_playback_time(time_sec)
--         # 同步音符发声状态
--         if self.is_playing:
--             self._sync_notes_at_time(time_sec)
--@@ -1199,6 +1476,17 @@ class EditorWindow(QMainWindow):
--         self.piano_roll.pixels_per_second = float(value)
--         self.piano_roll._refresh_notes()
--         self.timeline.set_scale(float(value))
--+        # 同步按键进度窗
--+        if self.chk_key_list.isChecked():
--+            self.key_list.set_scale(float(value))
--+
--+    def _sync_scroll_from_key_list(self, value: int):
--+        """从按键进度窗同步水平滚动到 PianoRollWidget"""
--+        self.piano_roll.horizontalScrollBar().blockSignals(True)
--+        self.piano_roll.horizontalScrollBar().setValue(value)
--+        self.piano_roll.horizontalScrollBar().blockSignals(False)
--+        # 同步时间轴
--+        self.timeline.set_scroll_offset(value)
-- 
--     def _on_piano_roll_zoom(self, pixels_per_second: float):
--         """缩放变化 (来自 Ctrl+滚轮)"""
--@@ -1208,6 +1496,9 @@ class EditorWindow(QMainWindow):
--         self.zoom_slider.blockSignals(True)
--         self.zoom_slider.setValue(int(pixels_per_second))
--         self.zoom_slider.blockSignals(False)
--+        # 同步按键进度窗
--+        if self.chk_key_list.isChecked():
--+            self.key_list.set_scale(pixels_per_second)
-- 
--     def _on_row_height_changed(self, pixels_per_note: float):
--         """行高变化 (来自 Ctrl+Up/Down 或 [ ])"""
--@@ -1265,6 +1556,10 @@ class EditorWindow(QMainWindow):
--         self.timeline.set_playhead(self.playback_time)
--         self._update_time_label()
-- 
--+        # 更新按键列表进度
--+        if self.chk_key_list.isChecked():
--+            self.key_list.update_playback_time(self.playback_time)
--+
--     def _update_time_label(self):
--         """更新时间显示"""
--         current = self.playback_time
--@@ -1598,3 +1893,164 @@ class EditorWindow(QMainWindow):
--             "Index Maintenance",
--             "\n".join(lines)
--         )
--+
--+    # ─────────────────────────────────────────────────────────────────────────
--+    # Unified Playback: Follow Mode Methods
--+    # ─────────────────────────────────────────────────────────────────────────
--+
--+    def set_follow_mode(self, follow: bool):
--+        """Switch to follow mode (disable local playback + audio).
--+
--+        In follow mode, the editor follows PlayerThread signals instead of
--+        using its internal QTimer-based playback.
--+        """
--+        self._follow_mode = follow
--+        if follow:
--+            # Stop local playback timer
--+            self.playback_timer.stop()
--+            self._release_all_notes()  # Stop FluidSynth
--+
--+            # Save original audio state before disabling (Pitfall #5)
--+            self._audio_was_enabled = self.chk_enable_audio.isChecked()
--+
--+            # Force disable audio checkbox (禁止双重发声)
--+            self.chk_enable_audio.setChecked(False)
--+            self.chk_enable_audio.setEnabled(False)
--+
--+            self.is_playing = True  # Visual state
--+            self.act_play.setText("Pause")
--+        else:
--+            # Restore audio checkbox to original state (Pitfall #5)
--+            self.chk_enable_audio.setEnabled(True)
--+            if hasattr(self, '_audio_was_enabled'):
--+                self.chk_enable_audio.setChecked(self._audio_was_enabled)
--+
--+            self.is_playing = False
--+            self.act_play.setText("Play")
--+
--+    def export_events(self) -> list:
--+        """Export current piano_roll notes as event list for PlayerThread.
--+
--+        Returns:
--+            List of note event dicts sorted by time.
--+        """
--+        # Sync drag offsets to notes data (Pitfall #1)
--+        self.piano_roll._sync_notes_from_graphics()
--+
--+        events = []
--+        for note_item in self.piano_roll.notes:
--+            events.append({
--+                "time": note_item.start_time,
--+                "note": note_item.note,
--+                "duration": note_item.duration,
--+                "velocity": getattr(note_item, 'velocity', 80),
--+                "channel": getattr(note_item, 'channel', 0),
--+            })
--+        return sorted(events, key=lambda e: e["time"])
--+
--+    def get_bar_duration(self) -> float:
--+        """Calculate bar duration from current editor BPM.
--+
--+        Returns:
--+            Bar duration in seconds (assumes 4/4 time signature).
--+        """
--+        bpm = self.sp_bpm.value() if hasattr(self, 'sp_bpm') else 120
--+        beats_per_bar = 4  # Default 4/4
--+        return 60.0 / bpm * beats_per_bar
--+
--+    def get_pause_bars(self) -> int:
--+        """Get auto-pause interval (bars).
--+
--+        Returns:
--+            Number of bars between auto-pauses (0 = disabled).
--+        """
--+        return self.cmb_pause_bars.currentData() if hasattr(self, 'cmb_pause_bars') else 0
--+
--+    def get_auto_resume_countdown(self) -> int:
--+        """Get auto-resume countdown seconds.
--+
--+        Returns:
--+            Countdown seconds before auto-resume.
--+        """
--+        return self.sp_auto_resume.value() if hasattr(self, 'sp_auto_resume') else 3
--+
--+    def get_octave_shift(self) -> int:
--+        """Get overall octave shift.
--+
--+        Returns:
--+            Octave shift (-2 to +2).
--+        """
--+        return self.sp_octave_shift.value() if hasattr(self, 'sp_octave_shift') else 0
--+
--+    def get_input_style(self) -> str:
--+        """Get selected input style for playback.
--+
--+        Returns:
--+            Input style name (e.g., 'mechanical', 'gentle').
--+        """
--+        if hasattr(self, 'cmb_input_style'):
--+            return self.cmb_input_style.currentText()
--+        return "mechanical"
--+
--+    def _populate_input_styles(self):
--+        """Populate input style combo box from registry."""
--+        self.cmb_input_style.clear()
--+        styles = get_style_names()
--+        self.cmb_input_style.addItems(styles)
--+        # Default to 'mechanical' if available
--+        if "mechanical" in styles:
--+            self.cmb_input_style.setCurrentText("mechanical")
--+
--+    def on_external_progress(self, current_time: float, total_duration: float):
--+        """Called by PlayerThread.progress signal.
--+
--+        Updates playhead position in the editor without playing audio.
--+        """
--+        if not self._follow_mode:
--+            return
--+
--+        self.playback_time = current_time
--+        self.piano_roll.set_playhead_position(current_time)
--+        self.timeline.set_playhead(current_time)
--+        self._update_time_label()
--+        # 更新按键列表进度
--+        if self.chk_key_list.isChecked():
--+            self.key_list.update_playback_time(current_time)
--+        # NO FluidSynth audio in follow mode (已禁用)
--+
--+    def on_external_paused(self):
--+        """Called when PlayerThread pauses."""
--+        if self._follow_mode:
--+            self.act_play.setText("Play")
--+
--+    def on_external_resumed(self):
--+        """Called when PlayerThread resumes (after pause or auto-pause countdown)."""
--+        if self._follow_mode:
--+            self.act_play.setText("Pause")
--+            # Clear countdown overlay when resumed
--+            self._countdown_overlay.hide_countdown()
--+
--+    def on_external_stopped(self):
--+        """Called when PlayerThread finishes."""
--+        self.set_follow_mode(False)
--+        self.on_stop()
--+
--+    def update_countdown(self, remaining: int):
--+        """Called by PlayerThread.countdown_tick signal.
--+
--+        Args:
--+            remaining: Seconds remaining (0 = countdown finished)
--+        """
--+        if remaining > 0:
--+            # Update hint text with i18n (get lang from parent/main window)
--+            lang = getattr(self.parent(), "lang", LANG_ZH)
--+            self._countdown_overlay.update_hint_text(tr("press_f5_continue", lang))
--+            self._countdown_overlay.show_countdown(remaining)
--+        else:
--+            self._countdown_overlay.hide_countdown()
--+
--+    def resizeEvent(self, event):
--+        """Handle resize to keep countdown overlay sized correctly."""
--+        super().resizeEvent(event)
--+        # Update overlay geometry to match piano_roll
--+        self._countdown_overlay.setGeometry(self.piano_roll.rect())
--diff --git a/LyreAutoPlayer/ui/editor/piano_roll.py b/LyreAutoPlayer/ui/editor/piano_roll.py
--index 6387d37..d31f62e 100644
----- a/LyreAutoPlayer/ui/editor/piano_roll.py
--+++ b/LyreAutoPlayer/ui/editor/piano_roll.py
--@@ -13,7 +13,7 @@ from .note_item import NoteItem
-- from .undo_commands import (
--     AddNoteCommand, DeleteNotesCommand, MoveNotesCommand,
--     TransposeCommand, QuantizeCommand, AutoTransposeCommand,
---    HumanizeCommand
--+    HumanizeCommand, ApplyJitterCommand
-- )
-- 
-- 
--diff --git a/LyreAutoPlayer/ui/editor/undo_commands.py b/LyreAutoPlayer/ui/editor/undo_commands.py
--index c00a016..08cf4cc 100644
----- a/LyreAutoPlayer/ui/editor/undo_commands.py
--+++ b/LyreAutoPlayer/ui/editor/undo_commands.py
--@@ -385,6 +385,98 @@ class HumanizeCommand(QUndoCommand):
-- 
--         pr._refresh_notes()
-- 
--+        # 更新总时长
--+        if pr.notes:
--+            pr.total_duration = max(n.start_time + n.duration for n in pr.notes)
--+
--+
--+class ApplyJitterCommand(QUndoCommand):
--+    """应用输入风格抖动命令
--+
--+    根据 InputStyle 参数对音符应用随机抖动：
--+    - timing_offset_ms: (min, max) 时间偏移范围 (毫秒, 均匀分布)
--+    - duration_variation: 时值变化比例 (负值=缩短)
--+    """
--+
--+    def __init__(self, piano_roll: "PianoRollWidget",
--+                 notes_data: List[dict],
--+                 timing_offset_ms: tuple = (0, 0),
--+                 duration_variation: float = 0.0,
--+                 style_name: str = ""):
--+        super().__init__(f"Apply '{style_name}' jitter to {len(notes_data)} Note(s)")
--+        self._piano_roll = piano_roll
--+        self._notes_data = [d.copy() for d in notes_data]
--+        self._timing_offset_ms = timing_offset_ms
--+        self._duration_variation = duration_variation
--+
--+        # 预生成随机偏移值 (确保 redo 一致性)
--+        min_offset, max_offset = timing_offset_ms
--+        self._offsets: List[dict] = []
--+        for _ in notes_data:
--+            # 时间偏移: 均匀分布
--+            if min_offset != 0 or max_offset != 0:
--+                timing_ms = random.uniform(min_offset, max_offset)
--+            else:
--+                timing_ms = 0.0
--+
--+            # 时值变化: 均匀分布
--+            if duration_variation != 0.0:
--+                if duration_variation < 0:
--+                    # 负值 = 只缩短 (staccato)
--+                    dur_var = random.uniform(duration_variation, 0)
--+                else:
--+                    dur_var = random.uniform(-duration_variation, duration_variation)
--+            else:
--+                dur_var = 0.0
--+
--+            self._offsets.append({
--+                "timing_sec": timing_ms / 1000.0,
--+                "duration_var": dur_var
--+            })
--+
--+    def redo(self):
--+        """执行/重做: 应用抖动偏移"""
--+        pr = self._piano_roll
--+
--+        for idx, data in enumerate(self._notes_data):
--+            for item in pr.notes:
--+                if (item.note == data["note"] and
--+                    abs(item.start_time - data["start"]) < 0.001 and
--+                    abs(item.duration - data["duration"]) < 0.001):
--+                    # 应用偏移
--+                    offset = self._offsets[idx]
--+                    item.start_time = max(0, data["start"] + offset["timing_sec"])
--+                    new_dur = data["duration"] * (1 + offset["duration_var"])
--+                    item.duration = max(0.01, new_dur)  # 最小 10ms
--+                    break
--+
--+        pr._refresh_notes()
--+
--+        # 更新总时长
--+        if pr.notes:
--+            pr.total_duration = max(n.start_time + n.duration for n in pr.notes)
--+
--+    def undo(self):
--+        """撤销: 恢复原始值"""
--+        pr = self._piano_roll
--+
--+        for idx, data in enumerate(self._notes_data):
--+            offset = self._offsets[idx]
--+            # 查找偏移后的音符
--+            target_start = max(0, data["start"] + offset["timing_sec"])
--+            target_dur = max(0.01, data["duration"] * (1 + offset["duration_var"]))
--+
--+            for item in pr.notes:
--+                if (item.note == data["note"] and
--+                    abs(item.start_time - target_start) < 0.01 and
--+                    abs(item.duration - target_dur) < 0.01):
--+                    # 恢复原始值
--+                    item.start_time = data["start"]
--+                    item.duration = data["duration"]
--+                    break
--+
--+        pr._refresh_notes()
--+
--         # 更新总时长
--         if pr.notes:
--             pr.total_duration = max(n.start_time + n.duration for n in pr.notes)
--\ No newline at end of file
--diff --git a/LyreAutoPlayer/ui/floating.py b/LyreAutoPlayer/ui/floating.py
--index c343dff..710d7a8 100644
----- a/LyreAutoPlayer/ui/floating.py
--+++ b/LyreAutoPlayer/ui/floating.py
--@@ -124,6 +124,16 @@ class FloatingController(QWidget):
--         info_row.addWidget(self.lbl_bpm)
--         layout.addLayout(info_row)
-- 
--+        # Countdown label (hidden by default)
--+        self.lbl_countdown = QLabel("")
--+        self.lbl_countdown.setStyleSheet(
--+            "font-size: 28px; font-weight: bold; color: #ffcc00; "
--+            "background: transparent;"
--+        )
--+        self.lbl_countdown.setAlignment(Qt.AlignmentFlag.AlignCenter)
--+        self.lbl_countdown.hide()
--+        layout.addWidget(self.lbl_countdown)
--+
--         layout.addStretch()
-- 
--     def _update_progress(self):
--@@ -142,6 +152,20 @@ class FloatingController(QWidget):
--         except Exception:
--             pass  # Ignore errors during update
-- 
--+    def show_countdown(self, remaining: int):
--+        """Show countdown overlay for auto-pause/resume.
--+
--+        Args:
--+            remaining: Seconds remaining (0 = countdown finished, hide)
--+        """
--+        if remaining > 0:
--+            self.lbl_countdown.setText(str(remaining))
--+            self.lbl_countdown.show()
--+            self.lbl_progress.hide()
--+        else:
--+            self.lbl_countdown.hide()
--+            self.lbl_progress.show()
--+
--     def set_file_name(self, name: str):
--         """Set the displayed file name."""
--         if name:
--diff --git a/LyreAutoPlayer/ui/mixins/config_mixin.py b/LyreAutoPlayer/ui/mixins/config_mixin.py
--index ca1d587..1b26d39 100644
----- a/LyreAutoPlayer/ui/mixins/config_mixin.py
--+++ b/LyreAutoPlayer/ui/mixins/config_mixin.py
--@@ -30,16 +30,21 @@ class ConfigMixin:
-- 
--     def collect_cfg(self: "MainWindow") -> PlayerConfig:
--         """Collect current UI values into PlayerConfig."""
---        # Build error config from UI
--+        # Check if strict mode is enabled
--+        strict_mode = getattr(self, '_strict_mode', False)
--+        if hasattr(self, 'chk_strict_mode'):
--+            strict_mode = self.chk_strict_mode.isChecked()
--+
--+        # Build error config (feature removed from main GUI - always disabled)
--         error_cfg = ErrorConfig(
---            enabled=self._error_enabled,
---            errors_per_8bars=self._error_freq,
---            wrong_note=self.chk_wrong_note.isChecked(),
---            miss_note=self.chk_miss_note.isChecked(),
---            extra_note=self.chk_extra_note.isChecked(),
---            pause_error=self.chk_pause_error.isChecked(),
---            pause_min_ms=self.sp_pause_min.value(),
---            pause_max_ms=self.sp_pause_max.value(),
--+            enabled=False,
--+            errors_per_8bars=0,
--+            wrong_note=False,
--+            miss_note=False,
--+            extra_note=False,
--+            pause_error=False,
--+            pause_min_ms=100,
--+            pause_max_ms=500,
--         )
-- 
--         octave_min = int(self.sp_octave_min.value())
--@@ -47,17 +52,32 @@ class ConfigMixin:
--         if octave_min > octave_max:
--             octave_min, octave_max = octave_max, octave_min
-- 
--+        # Build eight-bar style (disabled in strict mode)
--+        eight_bar = self._collect_eight_bar_style()
--+        if strict_mode:
--+            eight_bar.enabled = False
--+
--+        # Get pause_every_bars from UI if available
--+        pause_every_bars = 0
--+        if hasattr(self, 'cmb_pause_bars'):
--+            pause_every_bars = self.cmb_pause_bars.currentData() or 0
--+
--+        # Get auto_resume_countdown from UI if available
--+        auto_resume_countdown = 3
--+        if hasattr(self, 'sp_auto_resume_countdown'):
--+            auto_resume_countdown = self.sp_auto_resume_countdown.value()
--+
--         return PlayerConfig(
--             root_mid_do=int(self.cmb_root.currentData()),
--             octave_shift=int(self.cmb_octave.currentData()),
--             transpose=int(self.sp_transpose.value()),
---            speed=float(self.sp_speed.value()),
--+            speed=1.0 if strict_mode else float(self.sp_speed.value()),
--             accidental_policy=str(self.cmb_policy.currentText()),
--             octave_min_note=octave_min,
--             octave_max_note=octave_max,
--             octave_range_auto=self.chk_octave_range_auto.isChecked(),
--             press_ms=int(self.sp_press.value()),
---            use_midi_duration=self.chk_midi_duration.isChecked(),
--+            use_midi_duration=True if strict_mode else self.chk_midi_duration.isChecked(),
--             keyboard_preset=str(self.cmb_preset.currentData()),
--             countdown_sec=int(self.sp_countdown.value()),
--             target_hwnd=self.cmb_window.currentData(),
--@@ -66,34 +86,31 @@ class ConfigMixin:
--             soundfont_path=self.soundfont_path,
--             instrument=str(self.cmb_instrument.currentText()),
--             velocity=int(self.sp_velocity.value()),
---            input_style=self._current_input_style,
--+            input_style="mechanical" if strict_mode else self._current_input_style,
--             error_config=error_cfg,
--             enable_diagnostics=self._enable_diagnostics,
---            eight_bar_style=self._collect_eight_bar_style(),
--+            eight_bar_style=eight_bar,
--+            strict_mode=strict_mode,
--+            pause_every_bars=pause_every_bars,
--+            auto_resume_countdown=auto_resume_countdown,
--         )
-- 
--     def _collect_eight_bar_style(self: "MainWindow") -> EightBarStyle:
---        """Collect eight-bar style settings from UI."""
---        pattern_data = self.cmb_eight_bar_pattern.currentData()
---        mode_data = self.cmb_eight_bar_mode.currentData()
---        clamp_min = self.sp_eight_bar_clamp_min.value()
---        clamp_max = self.sp_eight_bar_clamp_max.value()
---        if clamp_min > clamp_max:
---            clamp_min, clamp_max = clamp_max, clamp_min
--+        """Return default disabled eight-bar style (feature removed from main GUI)."""
--         return EightBarStyle(
---            enabled=self.chk_eight_bar_enabled.isChecked(),
---            mode=mode_data if mode_data else "warp",
---            selection_pattern=pattern_data if pattern_data else "skip2_pick1",
---            speed_mult_min=self.sp_speed_min.value() / 100.0,
---            speed_mult_max=self.sp_speed_max.value() / 100.0,
---            timing_mult_min=self.sp_timing_var_min.value() / 100.0,
---            timing_mult_max=self.sp_timing_var_max.value() / 100.0,
---            duration_mult_min=self.sp_dur_var_min.value() / 100.0,
---            duration_mult_max=self.sp_dur_var_max.value() / 100.0,
---            clamp_enabled=self.chk_eight_bar_clamp.isChecked(),
---            clamp_min=clamp_min / 100.0,
---            clamp_max=clamp_max / 100.0,
---            show_indicator=self.chk_show_indicator.isChecked(),
--+            enabled=False,
--+            mode="warp",
--+            selection_pattern="skip2_pick1",
--+            speed_mult_min=0.95,
--+            speed_mult_max=1.05,
--+            timing_mult_min=0.95,
--+            timing_mult_max=1.05,
--+            duration_mult_min=0.95,
--+            duration_mult_max=1.05,
--+            clamp_enabled=False,
--+            clamp_min=0.85,
--+            clamp_max=1.15,
--+            show_indicator=False,
--         )
-- 
--     def save_settings(self: "MainWindow"):
--@@ -217,13 +234,10 @@ class ConfigMixin:
--             if "play_sound" in settings:
--                 self.chk_sound.setChecked(settings["play_sound"])
-- 
---            # Apply input style
--+            # Apply input style (only store the value - UI controls removed from main GUI)
--             if "input_style" in settings:
--                 style_name = settings["input_style"]
--                 self._current_input_style = style_name
---                self._select_style_in_combo(self.cmb_input_style, style_name)
---                self._select_style_in_combo(self.cmb_style_tab, style_name)
---                self._update_style_params_display(style_name)
-- 
--             # Apply soundfont path
--             if "soundfont_path" in settings and settings["soundfont_path"]:
--@@ -253,71 +267,30 @@ class ConfigMixin:
--             if "input_manager" in settings:
--                 self._input_manager_params = settings["input_manager"]
-- 
---            # Apply error_config (nested structure)
--+            # Apply error_config (feature removed from main GUI - just store internal state)
--             if "error_config" in settings:
--                 ec = settings["error_config"]
--                 if "enabled" in ec:
--                     self._error_enabled = ec["enabled"]
---                    self.chk_error_enabled.setChecked(ec["enabled"])
---                    self.chk_quick_error_enable.setChecked(ec["enabled"])
--                 if "errors_per_8bars" in ec:
--                     self._error_freq = ec["errors_per_8bars"]
---                    self.sp_error_freq.setValue(ec["errors_per_8bars"])
---                if "wrong_note" in ec:
---                    self.chk_wrong_note.setChecked(ec["wrong_note"])
---                    self.chk_quick_wrong.setChecked(ec["wrong_note"])
---                if "miss_note" in ec:
---                    self.chk_miss_note.setChecked(ec["miss_note"])
---                    self.chk_quick_miss.setChecked(ec["miss_note"])
---                if "extra_note" in ec:
---                    self.chk_extra_note.setChecked(ec["extra_note"])
---                    self.chk_quick_extra.setChecked(ec["extra_note"])
---                if "pause_error" in ec:
---                    self.chk_pause_error.setChecked(ec["pause_error"])
---                    self.chk_quick_pause.setChecked(ec["pause_error"])
---                if "pause_min_ms" in ec:
---                    self.sp_pause_min.setValue(ec["pause_min_ms"])
---                if "pause_max_ms" in ec:
---                    self.sp_pause_max.setValue(ec["pause_max_ms"])
---
---            # Apply eight_bar_config (nested structure)
---            if "eight_bar_config" in settings:
---                ebc = settings["eight_bar_config"]
---                if "enabled" in ebc:
---                    self.chk_eight_bar_enabled.setChecked(ebc["enabled"])
---                    self.chk_quick_eight_bar.setChecked(ebc["enabled"])
---                if "mode" in ebc:
---                    mode = ebc["mode"]
---                    for i in range(self.cmb_eight_bar_mode.count()):
---                        if self.cmb_eight_bar_mode.itemData(i) == mode:
---                            self.cmb_eight_bar_mode.setCurrentIndex(i)
---                            break
---                if "pattern" in ebc:
---                    pattern = ebc["pattern"]
---                    for i in range(self.cmb_eight_bar_pattern.count()):
---                        if self.cmb_eight_bar_pattern.itemData(i) == pattern:
---                            self.cmb_eight_bar_pattern.setCurrentIndex(i)
--+
--+            # Apply eight_bar_config (feature removed from main GUI - skip widget updates)
--+
--+            # Apply strict_mode_config (nested structure)
--+            if "strict_mode_config" in settings:
--+                smc = settings["strict_mode_config"]
--+                if "enabled" in smc and hasattr(self, 'chk_strict_mode'):
--+                    self.chk_strict_mode.setChecked(smc["enabled"])
--+                    self._strict_mode = smc["enabled"]
--+                if "pause_every_bars" in smc and hasattr(self, 'cmb_pause_bars'):
--+                    pause_bars = smc["pause_every_bars"]
--+                    for i in range(self.cmb_pause_bars.count()):
--+                        if self.cmb_pause_bars.itemData(i) == pause_bars:
--+                            self.cmb_pause_bars.setCurrentIndex(i)
--                             break
---                if "speed_min" in ebc:
---                    self.sp_speed_min.setValue(ebc["speed_min"])
---                if "speed_max" in ebc:
---                    self.sp_speed_max.setValue(ebc["speed_max"])
---                if "timing_min" in ebc:
---                    self.sp_timing_var_min.setValue(ebc["timing_min"])
---                if "timing_max" in ebc:
---                    self.sp_timing_var_max.setValue(ebc["timing_max"])
---                if "duration_min" in ebc:
---                    self.sp_dur_var_min.setValue(ebc["duration_min"])
---                if "duration_max" in ebc:
---                    self.sp_dur_var_max.setValue(ebc["duration_max"])
---                if "clamp_enabled" in ebc:
---                    self.chk_eight_bar_clamp.setChecked(ebc["clamp_enabled"])
---                if "clamp_min" in ebc:
---                    self.sp_eight_bar_clamp_min.setValue(ebc["clamp_min"])
---                if "clamp_max" in ebc:
---                    self.sp_eight_bar_clamp_max.setValue(ebc["clamp_max"])
---                if "show_indicator" in ebc:
---                    self.chk_show_indicator.setChecked(ebc["show_indicator"])
--+                if "auto_resume_countdown" in smc and hasattr(self, 'sp_auto_resume_countdown'):
--+                    self.sp_auto_resume_countdown.setValue(smc["auto_resume_countdown"])
-- 
--             # Unconditionally sync diagnostics state after loading
--             self._sync_diagnostics_state()
--diff --git a/LyreAutoPlayer/ui/mixins/playback_mixin.py b/LyreAutoPlayer/ui/mixins/playback_mixin.py
--index 122b667..03925bd 100644
----- a/LyreAutoPlayer/ui/mixins/playback_mixin.py
--+++ b/LyreAutoPlayer/ui/mixins/playback_mixin.py
--@@ -6,6 +6,7 @@ from typing import TYPE_CHECKING
-- from PyQt6.QtWidgets import QMessageBox
-- 
-- from player import PlayerThread
--+from player.midi_parser import NoteEvent
-- from i18n import tr
-- 
-- if TYPE_CHECKING:
--@@ -24,12 +25,52 @@ class PlaybackMixin:
--             return
-- 
--         cfg = self.collect_cfg()
---        self.thread = PlayerThread(self.events, cfg)
--+
--+        # Unified Playback: Get events from editor if available
--+        events_to_use = self.events
--+        editor = getattr(self, 'editor_window', None)
--+        if editor is not None and editor.isVisible():
--+            # Export events from editor (syncs drag offsets)
--+            editor_events = editor.export_events()
--+            if editor_events:
--+                # Convert dict to NoteEvent objects
--+                events_to_use = [
--+                    NoteEvent(time=ev["time"], note=ev["note"], duration=ev["duration"])
--+                    for ev in editor_events
--+                ]
--+                self.append_log(f"Using {len(events_to_use)} events from editor")
--+
--+            # Use editor BPM for bar duration calculation
--+            cfg.bar_duration_override = editor.get_bar_duration()
--+            cfg.editor_bpm = editor.sp_bpm.value() if hasattr(editor, 'sp_bpm') else 0
--+
--+            # Use editor's pause, octave, and input style settings
--+            cfg.pause_every_bars = editor.get_pause_bars()
--+            cfg.auto_resume_countdown = editor.get_auto_resume_countdown()
--+            cfg.octave_shift = editor.get_octave_shift()
--+            cfg.input_style = editor.get_input_style()
--+
--+        self.thread = PlayerThread(events_to_use, cfg)
--         self.thread.log.connect(self.append_log)
--         self.thread.finished.connect(self.on_finished)
--         self.thread.paused.connect(self._on_thread_paused)
--+        self.thread.resumed.connect(self._on_thread_resumed)
--         self.thread.progress.connect(self._on_progress_update)
-- 
--+        # Connect countdown signals
--+        self.thread.countdown_tick.connect(self._on_countdown_tick)
--+        self.thread.auto_pause_at_bar.connect(self._on_auto_pause_at_bar)
--+
--+        # Connect to EditorWindow if open
--+        if editor is not None and editor.isVisible():
--+            self.thread.progress.connect(editor.on_external_progress)
--+            self.thread.paused.connect(editor.on_external_paused)
--+            self.thread.resumed.connect(editor.on_external_resumed)
--+            self.thread.finished.connect(editor.on_external_stopped)
--+            self.thread.countdown_tick.connect(editor.update_countdown)
--+            editor.set_follow_mode(True)
--+            editor._main_window = self
--+
--         self.btn_start.setEnabled(False)
--         self.btn_stop.setEnabled(True)
--         # Update floating controller playback state
--@@ -115,6 +156,11 @@ class PlaybackMixin:
--         if self.floating_controller:
--             self.floating_controller.update_playback_state(True, is_paused=True)
-- 
--+    def _on_thread_resumed(self: "MainWindow"):
--+        """Called when playback thread resumes (after pause or auto-pause countdown)."""
--+        if self.floating_controller:
--+            self.floating_controller.update_playback_state(True, is_paused=False, is_pending=False)
--+
--     def _on_progress_update(self: "MainWindow", current_time: float, total_duration: float):
--         """Called when playback progress updates."""
--         self.current_time = current_time
--@@ -123,6 +169,16 @@ class PlaybackMixin:
--         if self.floating_controller and self.floating_controller.isVisible():
--             self.floating_controller._update_progress()
-- 
--+    def _on_countdown_tick(self: "MainWindow", remaining: int):
--+        """Called when countdown tick updates (for auto-pause/resume)."""
--+        # Forward countdown to floating controller
--+        if self.floating_controller and self.floating_controller.isVisible():
--+            self.floating_controller.show_countdown(remaining)
--+
--+    def _on_auto_pause_at_bar(self: "MainWindow", bar_index: int):
--+        """Called when auto-pause triggers at a bar boundary."""
--+        self.append_log(f"Auto-paused at bar {bar_index}")
--+
--     def on_octave_up(self: "MainWindow"):
--         """Shortcut handler: increase octave shift."""
--         idx = self.cmb_octave.currentIndex()
--diff --git a/LyreAutoPlayer/ui/mixins/settings_preset_mixin.py b/LyreAutoPlayer/ui/mixins/settings_preset_mixin.py
--index 8cb6837..38b20e1 100644
----- a/LyreAutoPlayer/ui/mixins/settings_preset_mixin.py
--+++ b/LyreAutoPlayer/ui/mixins/settings_preset_mixin.py
--@@ -39,9 +39,6 @@ class SettingsPresetMixin:
--         if 'input_style' in preset_settings:
--             style_name = preset_settings['input_style']
--             self._current_input_style = style_name
---            self._select_style_in_combo(self.cmb_input_style, style_name)
---            self._select_style_in_combo(self.cmb_style_tab, style_name)
---            self._update_style_params_display(style_name)
-- 
--         if 'press_ms' in preset_settings:
--             self.sp_press.setValue(preset_settings['press_ms'])
--@@ -63,21 +60,13 @@ class SettingsPresetMixin:
--                 self._input_manager_params = {}
--             self._input_manager_params.update(im)
-- 
--+        # Error config - feature removed from main GUI, just store internal state
--         if 'error_config' in preset_settings:
--             ec = preset_settings['error_config']
--             if 'enabled' in ec:
--                 self._error_enabled = ec['enabled']
---                self.chk_error_enabled.setChecked(ec['enabled'])
---                self.chk_quick_error_enable.setChecked(ec['enabled'])
--             if 'errors_per_8bars' in ec:
--                 self._error_freq = ec['errors_per_8bars']
---                self.sp_error_freq.setValue(ec['errors_per_8bars'])
---            if 'wrong_note' in ec:
---                self.chk_wrong_note.setChecked(ec['wrong_note'])
---                self.chk_quick_wrong.setChecked(ec['wrong_note'])
---            if 'miss_note' in ec:
---                self.chk_miss_note.setChecked(ec['miss_note'])
---                self.chk_quick_miss.setChecked(ec['miss_note'])
-- 
--         name = preset['name_zh'] if self.lang == LANG_ZH else preset['name_en']
--         self.append_log(f"[OK] {tr('preset_applied', self.lang)}: {name}")
--@@ -109,19 +98,12 @@ class SettingsPresetMixin:
--         self.chk_sound.setChecked(False)
--         self.sp_velocity.setValue(90)
-- 
--+        # Input style - just store internal state (UI controls removed from main GUI)
--         self._current_input_style = 'mechanical'
---        self._select_style_in_combo(self.cmb_input_style, 'mechanical')
---        self._select_style_in_combo(self.cmb_style_tab, 'mechanical')
---        self._update_style_params_display('mechanical')
-- 
--+        # Error config - feature removed from main GUI
--         self._error_enabled = False
--         self._error_freq = 1
---        self.chk_error_enabled.setChecked(False)
---        self.chk_quick_error_enable.setChecked(False)
---        self.sp_error_freq.setValue(1)
---        self.chk_eight_bar_clamp.setChecked(False)
---        self.sp_eight_bar_clamp_min.setValue(85)
---        self.sp_eight_bar_clamp_max.setValue(115)
-- 
--         self.append_log(f"[OK] {tr('reset_defaults', self.lang)}")
-- 
--@@ -166,30 +148,37 @@ class SettingsPresetMixin:
--             "soundfont_path": getattr(self, 'soundfont_path', '') or '',
--             "last_midi_path": getattr(self, 'mid_path', '') or '',
--             "input_manager": getattr(self, '_input_manager_params', {}),
--+            # Error config - feature removed from main GUI, use stored state
--             "error_config": {
---                "enabled": self._error_enabled,
---                "errors_per_8bars": self._error_freq,
---                "wrong_note": self.chk_wrong_note.isChecked(),
---                "miss_note": self.chk_miss_note.isChecked(),
---                "extra_note": self.chk_extra_note.isChecked(),
---                "pause_error": self.chk_pause_error.isChecked(),
---                "pause_min_ms": self.sp_pause_min.value(),
---                "pause_max_ms": self.sp_pause_max.value(),
--+                "enabled": getattr(self, '_error_enabled', False),
--+                "errors_per_8bars": getattr(self, '_error_freq', 0),
--+                "wrong_note": False,
--+                "miss_note": False,
--+                "extra_note": False,
--+                "pause_error": False,
--+                "pause_min_ms": 100,
--+                "pause_max_ms": 500,
--             },
--+            # Eight-bar config - feature removed from main GUI
--             "eight_bar_config": {
---                "enabled": self.chk_eight_bar_enabled.isChecked(),
---                "mode": self.cmb_eight_bar_mode.currentData() or "warp",
---                "pattern": self.cmb_eight_bar_pattern.currentData() or "skip2_pick1",
---                "speed_min": self.sp_speed_min.value(),
---                "speed_max": self.sp_speed_max.value(),
---                "timing_min": self.sp_timing_var_min.value(),
---                "timing_max": self.sp_timing_var_max.value(),
---                "duration_min": self.sp_dur_var_min.value(),
---                "duration_max": self.sp_dur_var_max.value(),
---                "clamp_enabled": self.chk_eight_bar_clamp.isChecked(),
---                "clamp_min": self.sp_eight_bar_clamp_min.value(),
---                "clamp_max": self.sp_eight_bar_clamp_max.value(),
---                "show_indicator": self.chk_show_indicator.isChecked(),
--+                "enabled": False,
--+                "mode": "warp",
--+                "pattern": "skip2_pick1",
--+                "speed_min": 95,
--+                "speed_max": 105,
--+                "timing_min": 95,
--+                "timing_max": 105,
--+                "duration_min": 95,
--+                "duration_max": 105,
--+                "clamp_enabled": False,
--+                "clamp_min": 85,
--+                "clamp_max": 115,
--+                "show_indicator": False,
--+            },
--+            "strict_mode_config": {
--+                "enabled": hasattr(self, 'chk_strict_mode') and self.chk_strict_mode.isChecked(),
--+                "pause_every_bars": self.cmb_pause_bars.currentData() if hasattr(self, 'cmb_pause_bars') else 0,
--+                "auto_resume_countdown": self.sp_auto_resume_countdown.value() if hasattr(self, 'sp_auto_resume_countdown') else 3,
--             },
--         }
-- 
--@@ -245,38 +234,17 @@ class SettingsPresetMixin:
--         if "play_sound" in settings:
--             self.chk_sound.setChecked(settings["play_sound"])
-- 
--+        # Input style - just store internal state (UI controls removed from main GUI)
--         if "input_style" in settings:
---            style_name = settings["input_style"]
---            self._current_input_style = style_name
---            self._select_style_in_combo(self.cmb_input_style, style_name)
---            self._select_style_in_combo(self.cmb_style_tab, style_name)
---            self._update_style_params_display(style_name)
--+            self._current_input_style = settings["input_style"]
-- 
--+        # Error config - feature removed from main GUI, just store internal state
--         if "error_config" in settings:
--             ec = settings["error_config"]
--             if "enabled" in ec:
--                 self._error_enabled = ec["enabled"]
---                self.chk_error_enabled.setChecked(ec["enabled"])
---                self.chk_quick_error_enable.setChecked(ec["enabled"])
--             if "errors_per_8bars" in ec:
--                 self._error_freq = ec["errors_per_8bars"]
---                self.sp_error_freq.setValue(ec["errors_per_8bars"])
---            if "wrong_note" in ec:
---                self.chk_wrong_note.setChecked(ec["wrong_note"])
---                self.chk_quick_wrong.setChecked(ec["wrong_note"])
---            if "miss_note" in ec:
---                self.chk_miss_note.setChecked(ec["miss_note"])
---                self.chk_quick_miss.setChecked(ec["miss_note"])
---            if "extra_note" in ec:
---                self.chk_extra_note.setChecked(ec["extra_note"])
---                self.chk_quick_extra.setChecked(ec["extra_note"])
---            if "pause_error" in ec:
---                self.chk_pause_error.setChecked(ec["pause_error"])
---                self.chk_quick_pause.setChecked(ec["pause_error"])
---            if "pause_min_ms" in ec:
---                self.sp_pause_min.setValue(ec["pause_min_ms"])
---            if "pause_max_ms" in ec:
---                self.sp_pause_max.setValue(ec["pause_max_ms"])
-- 
--         if "input_manager" in settings:
--             self._input_manager_params = settings["input_manager"]
--@@ -286,41 +254,4 @@ class SettingsPresetMixin:
--         # Unconditionally sync diagnostics state after preset apply
--         self._sync_diagnostics_state()
-- 
---        # Apply eight_bar_config (nested structure)
---        if "eight_bar_config" in settings:
---            ebc = settings["eight_bar_config"]
---            if "enabled" in ebc:
---                self.chk_eight_bar_enabled.setChecked(ebc["enabled"])
---                self.chk_quick_eight_bar.setChecked(ebc["enabled"])
---            if "mode" in ebc:
---                mode = ebc["mode"]
---                for i in range(self.cmb_eight_bar_mode.count()):
---                    if self.cmb_eight_bar_mode.itemData(i) == mode:
---                        self.cmb_eight_bar_mode.setCurrentIndex(i)
---                        break
---            if "pattern" in ebc:
---                pattern = ebc["pattern"]
---                for i in range(self.cmb_eight_bar_pattern.count()):
---                    if self.cmb_eight_bar_pattern.itemData(i) == pattern:
---                        self.cmb_eight_bar_pattern.setCurrentIndex(i)
---                        break
---            if "speed_min" in ebc:
---                self.sp_speed_min.setValue(ebc["speed_min"])
---            if "speed_max" in ebc:
---                self.sp_speed_max.setValue(ebc["speed_max"])
---            if "timing_min" in ebc:
---                self.sp_timing_var_min.setValue(ebc["timing_min"])
---            if "timing_max" in ebc:
---                self.sp_timing_var_max.setValue(ebc["timing_max"])
---            if "duration_min" in ebc:
---                self.sp_dur_var_min.setValue(ebc["duration_min"])
---            if "duration_max" in ebc:
---                self.sp_dur_var_max.setValue(ebc["duration_max"])
---            if "clamp_enabled" in ebc:
---                self.chk_eight_bar_clamp.setChecked(ebc["clamp_enabled"])
---            if "clamp_min" in ebc:
---                self.sp_eight_bar_clamp_min.setValue(ebc["clamp_min"])
---            if "clamp_max" in ebc:
---                self.sp_eight_bar_clamp_max.setValue(ebc["clamp_max"])
---            if "show_indicator" in ebc:
---                self.chk_show_indicator.setChecked(ebc["show_indicator"])
--+        # Eight-bar config - feature removed from main GUI, skip widget updates
--diff --git a/LyreAutoPlayer/ui/tab_builders.py b/LyreAutoPlayer/ui/tab_builders.py
--index 960a54a..1ec1197 100644
----- a/LyreAutoPlayer/ui/tab_builders.py
--+++ b/LyreAutoPlayer/ui/tab_builders.py
--@@ -109,13 +109,6 @@ def build_main_tab(window: "MainWindow") -> QWidget:
--     window.lbl_preset = QLabel()
--     form.addRow(window.lbl_preset, window.cmb_preset)
-- 
---    # Input style selector
---    window.cmb_input_style = QComboBox()
---    window._rebuild_style_combo(window.cmb_input_style)
---    window.cmb_input_style.currentIndexChanged.connect(window.on_input_style_changed)
---    window.lbl_input_style = QLabel()
---    form.addRow(window.lbl_input_style, window.cmb_input_style)
---
--     # Countdown
--     window.sp_countdown = QSpinBox()
--     window.sp_countdown.setRange(0, 10)
--@@ -169,48 +162,42 @@ def build_main_tab(window: "MainWindow") -> QWidget:
-- 
--     layout.addWidget(window.grp_sound)
-- 
---    # --- Quick Error Select Group ---
---    window.grp_quick_error = QGroupBox()
---    quick_err_layout = QHBoxLayout(window.grp_quick_error)
---
---    window.chk_quick_error_enable = QCheckBox()
---    window.chk_quick_error_enable.setChecked(False)
---    window.chk_quick_error_enable.stateChanged.connect(window._on_quick_error_enable_changed)
---    quick_err_layout.addWidget(window.chk_quick_error_enable)
---
---    window.chk_quick_wrong = QCheckBox()
---    window.chk_quick_wrong.setChecked(True)
---    window.chk_quick_wrong.stateChanged.connect(window._sync_quick_errors_to_tab5)
---    quick_err_layout.addWidget(window.chk_quick_wrong)
---
---    window.chk_quick_miss = QCheckBox()
---    window.chk_quick_miss.setChecked(True)
---    window.chk_quick_miss.stateChanged.connect(window._sync_quick_errors_to_tab5)
---    quick_err_layout.addWidget(window.chk_quick_miss)
---
---    window.chk_quick_extra = QCheckBox()
---    window.chk_quick_extra.setChecked(True)
---    window.chk_quick_extra.stateChanged.connect(window._sync_quick_errors_to_tab5)
---    quick_err_layout.addWidget(window.chk_quick_extra)
---
---    window.chk_quick_pause = QCheckBox()
---    window.chk_quick_pause.setChecked(True)
---    window.chk_quick_pause.stateChanged.connect(window._sync_quick_errors_to_tab5)
---    quick_err_layout.addWidget(window.chk_quick_pause)
---
---    quick_err_layout.addStretch()
---    layout.addWidget(window.grp_quick_error)
---
---    # --- Quick 8-Bar Style Toggle ---
---    eight_bar_quick_row = QHBoxLayout()
---    window.chk_quick_eight_bar = QCheckBox()
---    window.chk_quick_eight_bar.setChecked(False)
---    window.chk_quick_eight_bar.stateChanged.connect(window._on_quick_eight_bar_changed)
---    window.lbl_quick_eight_bar = QLabel()
---    eight_bar_quick_row.addWidget(window.chk_quick_eight_bar)
---    eight_bar_quick_row.addWidget(window.lbl_quick_eight_bar)
---    eight_bar_quick_row.addStretch()
---    layout.addLayout(eight_bar_quick_row)
--+    # --- Strict Mode / Auto-Pause Group ---
--+    window.grp_strict_mode = QGroupBox()
--+    strict_form = QFormLayout(window.grp_strict_mode)
--+
--+    # Strict mode checkbox (default ON)
--+    window.chk_strict_mode = QCheckBox()
--+    window.chk_strict_mode.setChecked(True)
--+    window.chk_strict_mode.stateChanged.connect(window._on_strict_mode_changed)
--+    window.lbl_strict_mode = QLabel()
--+    strict_form.addRow(window.lbl_strict_mode, window.chk_strict_mode)
--+
--+    # Auto-pause interval selector
--+    pause_row = QHBoxLayout()
--+    window.cmb_pause_bars = QComboBox()
--+    window.cmb_pause_bars.addItem("Disabled", 0)
--+    window.cmb_pause_bars.addItem("Every bar", 1)
--+    window.cmb_pause_bars.addItem("Every 2 bars", 2)
--+    window.cmb_pause_bars.addItem("Every 4 bars", 4)
--+    window.cmb_pause_bars.addItem("Every 8 bars", 8)
--+    window.cmb_pause_bars.setCurrentIndex(0)
--+    window.lbl_pause_bars = QLabel()
--+    pause_row.addWidget(window.cmb_pause_bars)
--+    strict_form.addRow(window.lbl_pause_bars, pause_row)
--+
--+    # Auto-resume countdown spinner
--+    countdown_row = QHBoxLayout()
--+    window.sp_auto_resume_countdown = QSpinBox()
--+    window.sp_auto_resume_countdown.setRange(1, 10)
--+    window.sp_auto_resume_countdown.setValue(3)
--+    window.sp_auto_resume_countdown.setSuffix(" sec")
--+    window.lbl_auto_resume_countdown = QLabel()
--+    countdown_row.addWidget(window.sp_auto_resume_countdown)
--+    countdown_row.addStretch()
--+    strict_form.addRow(window.lbl_auto_resume_countdown, countdown_row)
--+
--+    layout.addWidget(window.grp_strict_mode)
-- 
--     # --- Settings Presets Group ---
--     window.grp_presets = QGroupBox()
